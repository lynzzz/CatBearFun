                                            Map syntax sugar:

1. Map traversal (遍历keySet而不要遍历entrySet)

for( keyType key : m.keySet()){

   value = m.get(key);
}


instead of

for( Map.Entry&lt;keyType, ValueType> e : m.entrySet(){
   
     key = e.getKey()
     value = e.getValue();
}



2. Use putIfAbsent to Construct map :  Map<Integer, List&lt;Integer>> m = new ArrayList&lt;>();


for(Node n : Nodes){
   m.putIfAbsent(n.x, new ArrayList<Integer>());          // 2 lines
   m.get(n.x).add(n.val);
}



instead of 

for(Node n : nodes){
   if ( !m.containsKey(n.x)){
      List&lt;Integer> arr = new ArrayList&lt;>();              // 7 lines
      arr.add(n.val);
      m.put(n.x, l);
   }else{
      m.get(n.x).add(n.val);
   }
}




3. use getOrDefault to count the occurrence of the element applying to 
Map<Integer, Integer> m = new HashMap<>()

for( int i : arr){
   m.put(i, m.getOrDefault(i, 0) + 1);
}


3.1 use getOrDefault to compare, 适用于对map 的count在做减法，当小于0后就不处理的case. 同时可能m不包含i. 
    LC 659

     if( m.getOrDefault(i, 0) > 0)

     it returns true if m contains i and the count of i is greater than 0.
     It returns false if m contains i but the count of i is less than 0 or
                         m doesn't contain i.





4. 如何把HashMap<Integer, Integer> m, 转化成List<Integer> representing keys, 转化成List<Integer> represent values;

   new ArrayList<Integer>(m.keySet())
   new ArrayList<Integer>(m.values())









                                     

5.   如何对ArrayList富裕初始值。
a     List<Integer> ret = Arrays.asList(1, 2, 3, 4, 5);
     List<String> ans = Arrays.asList("Joe", "Michael", "Cathy");



b.   ArrayList -> array  （ dynamic->static)
     
     return ret.stream().mapToInt(i->i).toArray();  // Course schedule II



6. Java Big Integer 

import java.math.BigInteger;  

public class HelloWorld{

     public static void main(String []args){
        
        BigInteger[] arr = new BigInteger[100];
        
        arr[0] = new BigInteger("0");
        arr[1] = new BigInteger("1");
        
        for( int i=2; i<100; i++){
            arr[i] = arr[i-1].add(arr[i-2]);
        }
        
        for( int i=0; i&lt;100; i++){
            System.out.println(arr[i].toString());
        }
     }
}













Stack:


1. value type comparison for Stack

Stack<Integer> ret = new Stack<>();
Stack<Integer> minStack = new Stack<>();

ret.peek() == minStack.peek() 这样比较出来的是reference type比较， 不是值比较
ret.peek().equals(miStack.peek()) 这样才是值比较.





1. Boolean[][] visited = new Boolean[row][col], 这样开出来的矩阵里面每个元素是null, 因为Boolean是reference type，这种矩阵在任何情况都没有用，还很难Debug
   boolean[][] visited = new boolean[row][col], 这样里面每个元素是false, 因为是primitive type.

2.  int x, int y,    x/y 化成 double  =》   Double result = new Double （x) /y
    比较两个double   Double.compare(double, double)  or Double.compareTo(Double)
