<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>
                                               Map 

1. Map traversal (遍历keySet而不要遍历entrySet)

for( keyType key : m.keySet()){

   value = m.get(key);
}



2. Use putIfAbsent to Construct map :  Map<Integer, List&lt;Integer>> m = new ArrayList&lt;>();


for(Node n : Nodes){
   m.putIfAbsent(n.x, new ArrayList<Integer>());       
   m.get(n.x).add(n.val);
}



instead of 

for(Node n : nodes){
   if ( !m.containsKey(n.x)){
      List&lt;Integer> arr = new ArrayList&lt;>();           
      arr.add(n.val);
      m.put(n.x, l);
   }else{
      m.get(n.x).add(n.val);
   }
}




3. use getOrDefault to count the occurrence of the element applying to 
Map<Integer, Integer> m = new HashMap<>()

for( int i : arr){
   m.put(i, m.getOrDefault(i, 0) + 1);
}




4. 如何把HashMap<Integer, Integer> m, 转化成List<Integer> representing keys, 转化成List<Integer> represent values;

   new ArrayList<Integer>(m.keySet())
   new ArrayList<Integer>(m.values())


5. How to parse hashmap: keySet()
   for( int key : m.keySet()){
      int value = m.get(key);
   }





                                                    ArrayList

                                     

1   如何对ArrayList富裕初始值。
a     List<Integer> ret = Arrays.asList(1, 2, 3, 4, 5);
     List<String> ans = Arrays.asList("Joe", "Michael", "Cathy");








                                                    ArrayList->array 
List<int[]> ret = new ArrayList<>();

   return ret.toArray(new int[ret.size()][]);




ArrayList takes HashSet 
    HashSet<String> set = new HashSet<>();
    return new ArrayList<String>(set)



                                                




                                                         Stack


1. value type comparison for Stack

Stack<Integer> ret = new Stack<>();
Stack<Integer> minStack = new Stack<>();

ret.peek() == minStack.peek() 这样比较出来的是reference type比较， 不是值比较
ret.peek().equals(miStack.peek()) 这样才是值比较.

2. 
push//
peek//
pop//  Removes the object at the top of this stack and returns that object as the value of this function.



                                                      

                                                        2D array 


1. Boolean[][] visited = new Boolean[row][col], 这样开出来的矩阵里面每个元素是null, 因为Boolean是reference type，这种矩阵在任何情况都没有用，还很难Debug
   boolean[][] visited = new boolean[row][col], 这样里面每个元素是false, 因为是primitive type.

2.  int x, int y,    x/y 化成 double  =》   Double result = new Double （x) /y
    比较两个double   Double.compare(double, double)  or Double.compareTo(Double)

</code></pre>
</body>

</html>



                                     Java sort（Saleforce aloha8)
1. 
如果输入是int[][] or int[], 就要用Arrays.sort()
int[] :  Arrays.sort(arr, (a,b)->(a-b));
int[][] : Arrays.sort(arr, (a, b) ->(a[0] - b[0]));


2.如果是list 就要用 Collections.sort();


3. 复杂表达式写法
Arrays.sort(intervals, (a,b)->(a[0] - b[0]));
Arrays.sort(intervals, (a,b)->( a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]));
Arrays.sort(intervals, (a,b)=>{
     
   if ( a[0] != b[0]){
      return a[0] - b[0];
   }
   
   return a[1] - b[1];

});


4. 对long 类型的写法
Collections.sort(arr, (a,b)->(Long.compare(a[0], b[0]))); 
Collections.sort(arr, (a,b)->(a[0] - b[0]));   // 如果元素是long类型，这样写编译通不过 


5. 按照size排序，
Arrays.sort(ret, (a,b)->(a.length() - b.length()))
需要注意的是如果a.length == b.length, a.length - b.length = 0, return 0 for no change





                                          Iterator

List<Integer> ret = new ArrayList<>();

Interator<Integer> it = ret.iterator();

// hasNext()
// next()







                                         String 
1. In java string is immutable, you cannot change it. if you want to change it ,you need to create a new String or using stringbuilder

String lowerCaseString = str.toLowerCase();


2. String is reference type in Java, the default value is null. When you define a string in Java,
   remember to initialize it "", otherwise it will be null. (Oracle interview)

   String str = "";












                                         StringBuilder
1. StringBuilder deleteCharAt(i); returns this object 
   sb.deleteCharAt(i); 新的string已经保存在sb里面。
   sb.insert(index, integer/char/string)   // insert, not insertCharAt






                                           

                                           Arrasys
1. 拷贝数组的前n个元素。 Arrays.copyOfRange(arr, start, end), where start is inclusive and end is exclusive.