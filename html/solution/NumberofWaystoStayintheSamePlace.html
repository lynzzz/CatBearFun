<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
This is similar to kNight Dialer.

DFS brute force => DFS memorization => DP


Solution 1: DFS brute force(会写DFS暴力很重要，至少是weak hire)
DFS top down： 第0步初始化，进入DFS，第一步走到哪里，第二部走到哪里，第N步的时候结束，检查是非满足条件。


class Solution {
    public int numWays(int steps, int arrLen) {
        return dfs(steps, arrLen, 0, 0);
    }

    int dfs(int steps, int arrLen, int curStep, int curPos){
        if ( curPos < 0 || curPos == arrLen){
            return 0;
        }

        if ( curStep == steps){
            if ( curPos == 0){
                return 1;
            }else{
                return 0;
            }
        }

        int total = 0;

        total = total + dfs(steps, arrLen, curStep+1, curPos-1);
        total = total + dfs(steps, arrLen, curStep+1, curPos+1);
        total = total + dfs(steps, arrLen, curStep+1, curPos);

        return total;
    }
}

n*2^n where n is step

Solution II: DFS + memorization
class Solution {
    int modulo = (int)Math.pow(10,9) + 7;
    public int numWays(int steps, int arrLen) {

        Integer[][] dp = new Integer[steps+1][arrLen];
        // 表示第几步走到哪个位置有几种走法。

        return dfs(steps, arrLen, dp, 0, 0);
    }

    int dfs(int steps, int arrLen, Integer[][] dp,  int step, int curPos){
        if ( curPos < 0 || curPos == arrLen){
            return 0;
        }

        if ( dp[step][curPos] != null){
            return dp[step][curPos];
        }

        if ( step == steps){
            if ( curPos == 0){
                return 1;
            }else{
                return 0;
            }
        }

        int total = 0;

        total = (total + dfs(steps, arrLen, dp, step+1, curPos-1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos+1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos))%modulo;

        dp[step][curPos] = total;

        return total;
    }
}

step * length

Solution III: DFS + memorization (内存优化，只和steps有关，与矩阵大小无关， 因为当前步数>steps/2就可以返回了，因为ii网友)
因为在往右就走不回去了）

1. 跳棋模型： 给定步数和走法限制，求多少种走法。
2. DFS带两参数: curStep, curPos.
3. 很容易优化成DFS + memorization。  dp[curStep][curPos]表示某步走到某个位置有几种走法，记录下来

class Solution {
    int modulo = (int)Math.pow(10,9) + 7;
    public int numWays(int steps, int arrLen) {

        Integer[][] dp = new Integer[steps+1][steps/2+1];

        return dfs(steps, arrLen, dp, 0, 0);
    }

    int dfs(int steps, int arrLen, Integer[][] dp,  int step, int curPos){
        if ( curPos < 0 || curPos == arrLen || curPos>steps/2){
            return 0;
        }

        if ( dp[step][curPos] != null){
            return dp[step][curPos];
        }

        if ( step == steps){
            if ( curPos == 0){
                return 1;
            }else{
                return 0;
            }
        }

        int total = 0;

        total = (total + dfs(steps, arrLen, dp, step+1, curPos-1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos+1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos))%modulo;

        dp[step][curPos] = total;

        return total;
    }
}



</body>
