<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>

Solution I : Union find
Time complexity : O ( e lg(e) ), where e is the number of edges.

class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        UF uf = new UF(edges);
        for( int[] edge : edges){
            if (!uf.union(edge[0], edge[1])){
                return edge;
            }
        }
        
        return new int[2];
    }
}


class UF{
    
    private HashMap<Integer, Integer> parent = new HashMap<>();
    private HashMap<Integer, Integer> rank = new HashMap<>();
    
    public UF(int[][] edges){
        
        for( int[] edge : edges){
            if ( !parent.containsKey(edge[0])){
                parent.put(edge[0], edge[0]);
                rank.put(edge[0], 0);
            }
            if ( !parent.containsKey(edge[1])){
                parent.put(edge[1], edge[1]);
                rank.put(edge[1], 0);
            }
        }   
    }
    
    public int find( int id){
        if ( parent.get(id) == id){
            return id;
        }
        return find(parent.get(id));
    }
    
    public boolean union(int id1, int id2){
        int root1 = find(id1);
        int root2 = find(id2);
        
        if ( root1 == root2){

            return false;
        }
        
        if ( rank.get(root1) > rank.get(root2)){
            parent.put(root2, root1);
        }else if ( rank.get(root1) < rank.get(root2)){
            parent.put(root1, root2);
        }else{
            parent.put(root1, root2);
            rank.put(root2, rank.get(root2)+1);
        }
        
        return true;
    }
    
    
}



Solution II DFS  : 建图之前先两点间走一次DFS,如果能走通，则说明这条边是多余的
Time complexity : O ( e * e )   = O(e^2);

class Solution {
    
    private boolean isCycle = false;
    
    public int[] findRedundantConnection(int[][] edges) {
        
        
        HashMap<Integer, ArrayList<Integer>> m = new HashMap<>();
        for( int i=0; i<=1000; i++){
            m.put(i, new ArrayList<>());
        }
        
        
        HashSet<Integer> set = new HashSet<>();

        for( int[] e : edges){
            
            if ( m.get(e[0]).size() != 0 && m.get(e[1]).size() != 0 )
            {
                set.add(e[0]);
                dfs( e[0], e[1], set, m);
                set.remove(e[0]);
            }
            
            if ( isCycle) return e;
            
            m.get(e[0]).add(e[1]);
            m.get(e[1]).add(e[0]);
            
        }
        
        return new int[2];
    }
    
    void dfs(int start, int end, HashSet<Integer> set, HashMap<Integer, ArrayList<Integer> > m){
        if ( start == end){
            isCycle = true;
            return;
        }
        
        for( int n : m.get(start) ){
            if ( set.contains(n)){
                continue;
            }
            
            set.add(n);
            dfs(n, end, set, m);
            set.remove(n);
        }
    }
}


</code></pre>





</div>




</body>
