<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>
<pre><code>
Union find Version easy without rank map
Time complexity 近似O(e)。 Leetcode: 1ms

  class Solution {
  int[] findRedundantConnection(int[][] edges) {
      UF uf = new UF();
      for (int[] edge : edges) {
          if (uf.union(edge[0], edge[1])) {
              return edge;
          }
      }
      return null;
  }

  class UF {
      int[] parent;
      UF() {
          parent = new int[2000];
          for (int i = 0; i < 2000; i++) {
              parent[i] = i;
          }
      }

      int find(int n) {
          if (parent[n] == n) {
              return n;
          }
          return find(parent[n]);
      }

      boolean union(int n1, int n2) {
          int p1 = find(n1);
          int p2 = find(n2);
          if (p1 == p2) {
              return true;
          }

          parent[p1] = p2;
          return false;
      }
  };

  }



Union find with rank map
Time complexity : O(e), Leetcode 1ms

class Solution {
    int[] findRedundantConnection(int[][] edges) {
        UF uf = new UF();
        for (int[] edge : edges) {
            if (uf.union(edge[0], edge[1])) {
                return edge;
            }
        }
        return null;
    }

    class UF {
        int[] parent;
        int[] rank;
        UF() {
            parent = new int[2000];
            rank = new int[2000];
            for (int i = 0; i < 1001; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }

        int find(int n) {
            if (parent[n] == n) {
                return n;
            }
            return find(parent[n]);
        }

        boolean union(int n1, int n2) {
            int p1 = find(n1);
            int p2 = find(n2);

            if ( p1 == p2) return true;

            if ( rank[p1] > rank[p2]){
                parent[p2] = p1;
            }
            else if( rank[p1] < rank[p2]){
                parent[p1] = p2;
            }else{
                parent[p1] = p2;
                rank[p2]++;
            }

            return false;
        }
    };
}

}



Solution II DFS  : 先建图，然后把此条边拆开，如果能联通，说明此条表是多余的
Time complexity : O (e) * O(e + v)  = O(e^2);   Leetcode: 20ms

class Solution {
    boolean ret = false;;
    public int[] findRedundantConnection(int[][] edges) {
        HashMap&lt;Integer, HashSet&lt;Integer>> graph = new HashMap&lt;>();
        for(int[] edge : edges){
            int from = edge[0];
            int to = edge[1];
            if (!graph.containsKey(from)){
                HashSet&lt;Integer> l = new HashSet&lt;>();
                l.add(to);
                graph.put(from,l);
            }else{
                graph.get(from).add(to);
            }

            if (!graph.containsKey(to)){
                HashSet&lt;Integer> l = new HashSet&lt;>();
                l.add(from);
                graph.put(to,l);
            }else{
                graph.get(to).add(from);
            }
        }

        int[] ans = null;
        HashSet&lt;Integer> set = new HashSet&lt;>();

        for(int[] edge: edges){
            int from = edge[0];
            int to = edge[1];
            graph.get(from).remove(to);

            set.add(from);
            hasPath(from, to, graph, set);
            set.remove(from);

            if (ret)
            ans = edge;

            ret =false;
            graph.get(from).add(to);
        }

        return ans;

    }

    void hasPath(int start, int end, HashMap&lt;Integer, HashSet&lt;Integer>> graph,
        HashSet&lt;Integer> set){
        if ( start == end){
            ret = true;
            return;
        }

        for(int neighbor : graph.get(start)){
            if ( set.contains(neighbor)){
                continue;
            }

            set.add(neighbor);
            hasPath(neighbor, end, graph, set);
            set.remove(neighbor);
        }
    }
}


</code></pre>





</div>




</body>
