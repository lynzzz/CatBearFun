<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>



Solution I 每个点做BFS : O(n^2)， 太慢

class Solution {
    
    HashMap&lt;Integer, List<Integer>> graph = new HashMap<>();

    
    public List&lt;Integer> findMinHeightTrees(int n, int[][] edges) {
        
        HashMap&lt;Integer, Integer> l = new HashMap<>();
        for( int i=0; i&lt;n; i++){
            graph.put(i, new ArrayList<Integer>());                             //初始化图的好处： 每个点都在图里，构造图的时候不用判断这个点是否在图里，做BFS时候也不用判断点是否在图里。
        }
        
        for( int[] e: edges){
            
            int from = e[0];
            int to = e[1];
            
            graph.get(from).add(to);
            graph.get(to).add(from);
        }
        
        
        for( int i=0; i&lt;n i++){
            l.put(i, bfs(i));
        }
        
        
        int min = Integer.MAX_VALUE;
        for( int key : l.keySet()){
            if ( l.get(key) < min){
                min = l.get(key);
            }
        }
        
        ArrayList<Integer> ret = new ArrayList<>();
        
        for( int key : l.keySet()){
            if ( l.get(key) == min){
                ret.add(key);
            }
        }
        
        return ret;
        
    }
    
    public int bfs(int n){
        
        Queue&lt;Integer> q = new LinkedList<>();
        HashSet&lt;Integer> set = new HashSet<>();
        
        q.add(n);
        set.add(n);
        
        int level = 0;
        while( !q.isEmpty()){
            int size = q.size();
            for( int i=0; i&lt;size; i++){
                int node = q.poll();
                
                for( int neighbor : graph.get(node)){
                    if ( set.contains(neighbor)){
                        continue;
                    }
                    
                    set.add(neighbor);
                    q.add(neighbor);
                }
            }
            level++;
        }
        
        return level;
    }
}


Solution II : Topological sorting  O(n)

class Solution {
    

    
    public List&lt;Integer> findMinHeightTrees(int n, int[][] edges) {
        if ( n == 1){
            ArrayList<Integer> ret = new ArrayList<>();
            ret.add(0);
            return ret;
        }
        
        HashMap&lt;Integer, ArrayList<Integer>> graph = new HashMap<>();
        for( int i=0; i&lt;n; i++){
            graph.put(i, new ArrayList<Integer>());
        }
        
        
        for( int[] e: edges){
            graph.get(e[0]).add(e[1]);
            graph.get(e[1]).add(e[0]);                   //Assuming no duplicate edges
        }
        
        
        
        Queue<Integer> q = new LinkedList<Integer>();
        
        for( int key : graph.keySet()){
            if ( graph.get(key).size() == 1){
                q.add(key);
            }
        }
        
        
        while( n > 2){
            
            int size = q.size();
            
            for( int k=0; k&lt;size; k++){
                
                int outRoot = q.poll();
                
                int innerRoot = graph.get(outRoot).get(0);
                ArrayList<Integer> innerRootNextLevel = graph.get(innerRoot);
                
                for( int i=0; i&lt;innerRootNextLevel.size(); i++){
                    if ( innerRootNextLevel.get(i) == outRoot){
                        innerRootNextLevel.remove(i);
                        break;
                    }
                }
                
                if ( graph.get(innerRoot).size() == 1){
                    q.add(innerRoot);
                }
            }
            
            n = n - size;
        }
        
        
        ArrayList<Integer> ret = new ArrayList<>();
        while( !q.isEmpty()){
            ret.add(q.poll());
        }
        
        return ret;
    }
}



Tree的定义：三无
1. 无向
2. 无环
3. 无孤

Tree的边和点的关系
O(V) = n
O(E)= n - 1;


Topological sorting + level order traversal

</code></pre>
















</div>




</body>
