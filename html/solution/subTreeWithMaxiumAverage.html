<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
public class Solution {
     
    class TreeHelperNode{
        int sum;
        int size;
        TreeHelperNode(int sum, int size){
            this.sum = sum;
            this.size = size;
        }
    }
     
    TreeNode result;
    TreeHelperNode resultHepler;
     
    public TreeNode findSubtree2(TreeNode root) {
        // Write your code here
        dfs(root);
        return result;
    }
    
    // 递归的定义 ： 构造一个和原来的树一模一样的树，但是每个节点是TreeHelperNode
    TreeHelperNode dfs(TreeNode root){
        
        // return condition ??
        if( root == null){
            return new TreeHelperNode(0,0);
        }
        
        TreeHelperNode leftHelper = dfs(root.left);
        TreeHelperNode rightHelper = dfs(root.right);
        
        TreeHelperNode rootHelper = new TreeHelperNode(root.val + leftHelper.sum + rightHelper.sum, 
                                                          1 + leftHelper.size + rightHelper.size);
        
        if ( result == null || rootHelper.sum * resultHepler.size > resultHepler.sum * rootHelper.size  ){
            result = root;
            resultHepler = rootHelper;
        }
        
        return rootHelper;
    }
}


</code></pre>






<div class="comment">
Time complexity :   O(n)   <br>
Space complexity :  O(1)   <br>


Algorithm<br>
分治从下往上建一个一模一样的树，但是每个节点是helper node。  维持一个全局最大average 节点 。

1.   <br>




<br>
Note <br>


<br>
Java Skill
1.          <br>
2.          <br>



<br>
Last Time completed at :


</div>




</body>
