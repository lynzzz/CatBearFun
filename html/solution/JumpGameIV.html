<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>

   class Solution {
      public int minJumps(int[] arr) {
         //418
          
          Queue<Integer> q = new LinkedList&lt;>();  
          q.add(0);
          HashSet<Integer> visited = new HashSet&lt;>();
          visited.add(0);
          
          int ret = 0;
          
          HashMap<Integer, List&lt;Integer>> map = new HashMap&lt;>();  // save the index. first optimization
          
          for( int i=0; i<arr.length; i++){
              int n = arr[i];
              map.putIfAbsent(n, new ArrayList&lt;Integer>());
              map.get(n).add(i);
          }
          
          
          while( !q.isEmpty()){
              int size = q.size();
              
              for( int i=0; i<size; i++){
                  int index = q.poll();
                  
                  if (index == arr.length - 1){
                      return ret;
                  }
                  
                  List&lt;Integer> next = map.get(arr[index]);
                  next.add(index-1);
                  next.add(index+1);
                  
                  for(int j: next){
                      if ( j>=0 && j<arr.length && !visited.contains(j)){  // visited去重
                          q.add(j);
                          visited.add(j);
                      }
                  }
                  
                  next.clear(); // 点睛之笔，index只加一次  avoid later lookup indicesOfValue arr[i]
              }
              
              ret++;
          }
          return -1;
      }
  }

  1. 两个优化， 
      a 一个是存  val -> List<Index>, 然后只能用一次
      b 用visited array去重。

</code></pre>
</body>
