<html>


<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>
<pre><code>

Solution 1:
class Solution {

    public List&lt;List&lt;Integer>> subsets(int[] nums) {
        // write your code here
        Arrays.sort(nums);

        ArrayList&lt;ArrayList&lt;Integer>> results = new ArrayList&lt;>();
        ArrayList&lt;Integer> result = new ArrayList&lt;>();
        dfs(results, result, nums, 0);
        return results;
    }

    private void dfs(ArrayListt&lt;ArrayList&lt;Integer>> results, ArrayListt&lt;Integer> result, int[] nums, int level){
        results.add(new ArrayList&lt;Integer>(result));

        for( int i=level; i &lt; nums.length; i++){
            result.add(nums[i]);
            dfs( results, result, nums,i+1 );
            result.remove(result.size()-1);
        }
    }
}

Solution 2: DFS里不带for loop的写法。一个DFS里包含两个不同的DFS功能
class Solution {
    public Listt&lt;List&lt;Integer>> subsets(int[] nums) {

       Listt&lt;List&lt;Integer>> results = new ArrayList&lt;>();
       dfs(results, new ArrayList&lt;Integer>(), nums, 0);

       return results;
    }

    void dfs(Listt&lt;List&lt;Integer>> results, Listt&lt;Integer> result, int[] nums, int pos){

          if ( pos == nums.length){
              results.add(new ArrayListt&lt;Integer>(result));
              return;
          }

           result.add(nums[pos]);
           dfs(results, result, nums, pos + 1);
           result.remove(result.size()-1);
           dfs(results, result, nums, pos + 1);
    }
}


</code>
</pre>


<div class="comment">
Subset（forward search）<br>
！！！！！！！！！！！！！！！！！！！！！！！！！！！！组合模板鼻祖！！！！！！！！！！！！！！<br>
<br>
和位置无关， 例子 [1，2，3]是解， [1，3，2]则不是解，因为不能有重复<br>
输入为 ： 大容器，小容器， 前进控制整数， 输入<br>
time O(n*2^(n)) <br>

<br>
Note:<br>
1. for( int i= level ; ; )   <br>
2. dfs(, , , i+1)            这里取i+1保证了下一层一直往前走，不会头。 注意不要写成了level+1, 这是不对的，因为level的值在for循环内是不会变的。<br>
</div>

</body>
</html>
