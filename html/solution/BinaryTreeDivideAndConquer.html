<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


二分树分治理解：一口气走到二叉树最底层，然后往上回溯加商业逻辑<br>
分治的特征： 有返回值，从下往上走<br>
<br>
<br>

分治先决条件：想清楚这个分治返回的是什么。（如果你这个没有想清楚， 题目是做不出来的）<br>

分治3部曲：
1. 结束条件.
2. 左儿子返回什么，右儿子返回什么.
3. 返回什么给父结点.


<pre><code>

// 搞清楚这个分治返回什么在开始写
int helper(TreeNode root){

   // 结束条件
   if ( root == null ) return 0;

  
   int left = helper(root.left);    // 看左儿子返回什么
   int right = helper(root.right);  // 看右儿子返回什么


   //conquer （治，往上走）
   return f(root.val, left, right);  // 我返回什么给我的父结点
}

</code></pre>

例子题目<br>
<ol>
<li><a href="subTreeWithMaxiumAverage.html">sub Tree With Maxium average(分治)</a> <a href=https://leetcode.com/problems/maximum-average-subtree/>Q</a>  </li>
<li><a href="BinaryTreeMaximumPathSum.html">Binary Tree Maximum PathSum(分治)</a> <a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/description/>Q</a>  </li>
<li><a href="SymmetricBinaryTree.html">symmetric binary tree(分治)</a> <a href=https://leetcode.com/problems/symmetric-tree/>Q</a>  </li>
<li><a href="BinaryTreeLongestConsecutiveSequence.html">Binary tree longest consecutive sequence(分治或者遍历套遍历)</a> <a href=https://leetcode.com/problems/binary-tree-longest-consecutive-sequence>Q</a>  </li>
<li><a href=https://leetcode.com/problems/distribute-coins-in-binary-tree/>Distribute coins in binary tree</a>  </li>
<li><a href=https://leetcode.com/problems/binary-tree-cameras>Binary tree camera</a>  </li>


</ol>


<img src="../../img/divideandConquer.JPG" height="800px" width="800px">


</body>
