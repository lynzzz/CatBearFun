<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<h2>

二分树分治理解：<br>


1. 可以理解成先一口气走到二叉树最底层，然后往上回溯加商业逻辑。

</h2>


<p>  分治模板  </p>
分治的特征： 有返回值，从下往上走。

分治三部曲：
1. 结束条件
2. 分（一口气走到二叉树底层）
3. 治 （往上走加商业逻辑）


<pre><code>


int helper(TreeNode root){

   // 结束条件
   if ( root == null )

   ／／ divide (分，一口气走到二叉树最底层)
   int left = helper(root.left);
   int right = helper(root.right);


   //conquer （治，往上走）
   return f(left, right);
}

</code></pre>

例子题目<br>
<ol>
<li><a href="subTreeWithMaxiumAverage.html">sub Tree With Maxium average(分治)</a> <a href=https://leetcode.com/problems/maximum-average-subtree/>Q</a>  </li>
<li><a href="BinaryTreeMaximumPathSum.html">Binary Tree Maximum PathSum(分治)</a> <a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/description/>Q</a>  </li>
<li><a href="SymmetricBinaryTree.html">symmetric binary tree(分治)</a> <a href=https://leetcode.com/problems/symmetric-tree/>Q</a>  </li>
<li><a href="BinaryTreeLongestConsecutiveSequence.html">Binary tree longest consecutive sequence(分治或者遍历套遍历)</a> <a href=https://leetcode.com/problems/binary-tree-longest-consecutive-sequence>Q</a>  </li>
<li><a href="https://leetcode.com/problems/unique-binary-search-trees-ii">Unique Binary Search Trees II(分治:这个recursion非常有意思)</a></li>


</ol>


<img src="../../img/divideandConquer.JPG" height="800px" width="800px">


</body>
