<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
Solution 1: DFS without return value:
class Solution {
    long total = 0;
    int module = (int)Math.pow(10, 9) + 7;

    public int knightDialer(int N) {

        HashMap&lt;Character, String> m = new HashMap&lt;>();
        m.put('0', "46");
        m.put('1', "68");
        m.put('2', "79");
        m.put('3', "48");
        m.put('4', "390");
        m.put('5', "");
        m.put('6', "170");
        m.put('7', "26");
        m.put('8', "13");
        m.put('9', "24");


        for( char c='0'; c<='9'; c++){
            dfs(N, m,  0, c);
        }

        return (int)total%module;
    }


    void dfs(int N, HashMap&lt;Character, String> m, int curStep, char curChar){

        if ( curStep == N-1){
            total++;
            return;
        }

        String next = m.get(curChar);

        for(int i=0; i&lt;next.length(); i++){
            char c = next.charAt(i);
            dfs(N, m, curStep+1, c);
        }
    }
}

Solution II:
DFS With return value:
class Solution {
    int module = (int)Math.pow(10, 9) + 7;

    public int knightDialer(int N) {

        HashMap&lt;Character, String> m = new HashMap&lt;>();
        m.put('0', "46");
        m.put('1', "68");
        m.put('2', "79");
        m.put('3', "48");
        m.put('4', "390");
        m.put('5', "");
        m.put('6', "170");
        m.put('7', "26");
        m.put('8', "13");
        m.put('9', "24");

        int total = 0;
        for( char c='0'; c<='9'; c++){
            total = total + dfs(N, m,  0, c);
        }

        return (int)total%module;
    }


    int dfs(int N, HashMap&lt;Character, String> m, int curStep, char curChar){

        if ( curStep == N-1){
            return 1;
        }

        String next = m.get(curChar);
        int total = 0;
        for(int i=0; i&lt;next.length(); i++){
            char c = next.charAt(i);
            total = total + dfs(N, m, curStep+1, c);
        }

        return total;
    }
}

Solution III:
DFS +  memorization:
class Solution {
    int module = (int)Math.pow(10, 9) + 7;

    public int knightDialer(int N) {

        HashMap&lt;Character, String> m = new HashMap&lt;>();
        Integer[][] mem = new Integer[N][10];

        m.put('0', "46");
        m.put('1', "68");
        m.put('2', "79");
        m.put('3', "48");
        m.put('4', "390");
        m.put('5', "");
        m.put('6', "170");
        m.put('7', "26");
        m.put('8', "13");
        m.put('9', "24");

        int total = 0;
        for( char c='0'; c<='9'; c++){
            total = (total + dfs(N, m,  0, c, mem))%module;
        }

        return total;
    }


    int dfs(int N, HashMap&lt;Character, String> m, int curStep, char curChar, Integer[][] mem){

        if ( curStep == N-1){
            return 1;
        }

        if ( mem[curStep][curChar - '0'] != null){
            return mem[curStep][curChar - '0'];
        }

        String next = m.get(curChar);
        int total = 0;
        for(int i=0; i&lt;next.length(); i++){
            char c = next.charAt(i);
            total = (total + dfs(N, m, curStep+1, c, mem))%module;
        }

        mem[curStep][curChar-'0'] = total;

        return total;
    }
}

Follow up: Next level mapping can be represented by integer to integer array: int[][]

Solution I : DFS brute force 没有返回值
class Solution {
    int module = (int)Math.pow(10, 9) + 7;
    int total = 0;

    public int knightDialer(int N) {
        int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};
        int total = 0;
        for( int i=0; i<=9; i++){
            dfs(N, dict, 0, i));
        }
        return total;
    }

    int dfs(int N, int[][] dict, int curStep, int curPos  ){
        if ( curStep == N-1){
            total++;
            return;
        }

        int total = 0;
        for(int i : dict[curPos]){
            dfs(N, dict, curStep+1, i));
        }
    }
}

Solution II : DFS brute force 有返回值
class Solution {
    int module = (int)Math.pow(10, 9) + 7;

    public int knightDialer(int N) {
        int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};
        int total = 0;
        for( int i=0; i<=9; i++){
            total = (total + dfs(N, dict, 1, i))%module;
        }
        return total;
    }

    int dfs(int N, int[][] dict, int curStep, int curPos  ){
        if ( curStep == N){
            return 1;
        }

        int total = 0;
        for(int i : dict[curPos]){
            total = (total + dfs(N, dict, curStep+1, i))%module;
        }
        return total;
    }
}

Solution III: DFS + memorization

class Solution {
    int module = (int)Math.pow(10, 9) + 7;

    public int knightDialer(int N) {

        Integer[][] mem = new Integer[N][10];  // row为步数，col为取的值。记录下来不用反复算。如第三步取8有多少种
        // 表示第几步走到哪个位置有几种走法。

        int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};

        int total = 0;
        for( int i=0; i<=9; i++){
            total = (total + dfs(N, dict, mem, 0, i))%module;
        }

        return total;
    }

    int dfs(int N, int[][] dict, Integer[][] mem, int curStep, int curPos ){

        if ( curStep == N-1){
            return 1;
        }

        if ( mem[curStep][curPos] != null){
            return mem[curStep][curPos];
        }

        int total = 0;
        for(int i : dict[curPos]){
            total = (total + dfs(N, dict, mem, curStep+1, i))%module;
        }
        mem[curStep][curPos] = total;
        return total;
    }
}

</code></pre>




<div class="comment">
Time complexity :  O(N)    <br>
Space complexity : O(N*10) = O(n)    <br>

0. 跳棋模型： 给定步数，求多少种跳法
1. DFS带两参数，一个是当前步数(CurStep)，一个是当前位置(CurPos)
2. 用DFS + Memorization，DFS一定要返回值。dp[curStep][curPos]表示某步走到某个位置有几种走法，记录下来


</div>




</body>
