
<html>
<body>



Solution 1:<br>

<pre><code>
    public int lengthOfLongestSubstring(String s) {
        // write your code here
        if ( s == null) return 0;
        
        int i = 0;
        int start =0;
        int ret = 0;
        
        Map&lt;Character, Integer> m = new HashMap<>();
        
        for( ; i&lt;s.length(); i++ ){
            
            if ( m.containsKey(s.charAt(i)) ){
                
                int length = i -start;
                if ( length > ret){
                    ret = length;
                }
                
                start = Math.max( start, m.get(s.charAt(i)) + 1);  // trick
                
            }
            m.put(s.charAt(i), i);
        }
        
        if ( ( i- start) > ret ){
            ret = i - start;
        }
        
        return ret;
    }
</code></pre>


// 最长无重复子串：  <br>
// 数据结构 ： Map : char-> index.  Maintain start;<br>
// 例子：abcdefge, 找到重复后start调到f, 更新start的位置。<br>
// Trick : Start 不能往后走 ：  an++--viaj, ( 当i走到第二个a的时候，start不能回到n)<br>
// Trick : 结束时需要在check一次长度，因为更新长度是在if里面。



<br>
<br>
<br>
<br>
Solution 2 : <br>
<pre><code>
public class Solution {
    /**
     * @param s: a string
     * @return: an integer 
     */
    public int lengthOfLongestSubstring(String s) {
        // write your code here
        int[] dict = new int[256];
        Arrays.fill(dict, -1);
        
        int length = 0;
        int max = 0;
        
        for( int i=0; i&lt;s.length(); ){
            
            if ( dict[s.charAt(i)] == -1 ){
                dict[s.charAt(i)] = i;
                length++;
                i++;
            }else{
                max = Math.max(max, length);
                i = dict[s.charAt(i)] + 1;
                Arrays.fill(dict, -1);
                length = 0;
            }  
        }
        
        
        return Math.max(length, max);
    }
}

// 最长无重复子串
// Hash table  Character -> last occurence in the array ( initialized to -1)
// sliding window, 维持 dict[] array, temp length, final length, i


//abcdefge, 我们从a开始,第二个 碰到e的时候,发现了重复第一个e之后的下一个(也就是f)开始再次的遍历.
//为了做到能够记录上一次出现e的位置,我们的山寨哈希表可以稍作修改,-1表示没有出现过, 正值表示上次出现的位置


time O(n)
</code></pre>







</html>