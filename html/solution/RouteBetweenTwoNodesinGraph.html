<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>

                                           什么时候用DFS : 能否在图中一点走到另外一点，这种题目能用DFS解答, <br>
										   
										   
										

无向图做BFS,DFS一定要去重， 否则A-> B ， B->A 可以反复递归无法结束。 但是递归结束可以返回上一层。

BFS
public class Solution {

    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {

        
        Queue&lt;DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        HashSet&lt;DirectedGraphNode> set = new HashSet<DirectedGraphNode>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            DirectedGraphNode node = q.poll();
            
            if ( node == t){
                return true;
            }
            
            for( DirectedGraphNode child : node.neighbors){
               
               if ( set.contains(child) ){
                   continue;
               }
                    
               set.add(child);
               q.add(child);
            }
        }
        
        return false;
    }
}

DFS


public class Solution {

    private boolean ret = false; 
     
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {

        HashSet<DirectedGraphNode> set = new HashSet<>();
        set.add(s);
        dfs(graph, s, t, set);
		set.remove(s);                                                 // 当最高层的DFS返回时，要把原来的start,清零。 不然多次DFS会出错。
		
        return ret;
    }
    
    
    void dfs( ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, 
              DirectedGraphNode t, HashSet<DirectedGraphNode> set ){
        
        if ( s == t){
            ret = true;
            return;
        }
        
        for( DirectedGraphNode neighbor : s.neighbors){                                     CADR : continue, add, DFS, remove
            if ( set.contains(neighbor)){
                continue;
            }
            
            set.add(neighbor);
            dfs( graph, neighbor, t, set);
            set.remove(neighbor);
        }
    }
}

图的遍历事件复杂度对于DFS, BFS都是 O(m+n)  ~= O(m) ~= O(n^2), where m is the number of edge and n is number of vertex









棋盘类DFS模板 

void dfs( start, matrix){

    1. 递归的结束条件 （ 一般是越界，或者撞墙）
	
	2. 递归达到某种要求（走到某点， 返回 ）
	
	3. 去重 （ 这一步，要开题目的走法， 如果按照题目的意思，你可以走回原来的坐标，就一定需要去重（如number of islands) 如果走不回去就可以不去重，因为下一层取不到, 如下题）
	   去重的方法一般是标记为墙。
	
	4.  braodcast DFS
}

棋盘类的BFS就标记为墙就可以了，如number of islands, 不需要用hashSet





Google 面试题目： 能不能从一点走到另外一点， 
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。

BFS解法
class Node{
int x;
int y;

}
void BFS(int x, int y, int m, int n){

     Queue<Node> q = new LinkedList<>();
	 q.add(new Node(x,y));
	 
	 while( ！q.isEmpty（））{
	     Node node = q.poll();
		 
		 if （ node.x == m, && node.y  == n){
		      return true;
		 }
		 
		 if ( 2*node.x <= m && node.y <= n)
		     q.add(Node(2*n.x, y);
		 
		 if ( n.x <= m && 2n.y<= m)
		     q.add(Node(n.x, 2*n.y(;
	 }
     
	 return false;
}


DFS 解法 
boolean ans = false;

void DFS(int x, int y, int m, int n){

	if ( x > m || y > n ){
	    return;
	}
	
    if ( x == m && y == n ){
	    ans = true;
		return;
	}
	


    DFS(2x, y, m, n);                                                    
	DFS(x, 2y, m, n);
}




</code></pre>












1. 注意的是图里面的DFS要用去重。<br>
2. 如果DFS的图是无限大的，你要强行加上结束条件，如上题。<br><br><br>







<div class="comment">
1. BFS or DFS 图里面搜索一般用BFS. 有时候DFS比BFS要好写些。 <br>
</div>




</body>
