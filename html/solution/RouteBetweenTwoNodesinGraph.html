<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
BFS
public class Solution {
   /**
     * @param graph: A list of Directed graph node
     * @param s: the starting Directed graph node
     * @param t: the terminal Directed graph node
     * @return: a boolean value
     */
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        // write your code here
        if ( s.label == t.label){
            return true;
        }
        
        Queue&lt;DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        HashSet<DirectedGraphNode> set = new HashSet<DirectedGraphNode>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            DirectedGraphNode node = q.poll();
            
            for( DirectedGraphNode child : node.neighbors){
                if ( !set.contains(child) ){
                    
                    if ( child.label == t.label){
                        return true;
                    }
                    set.add(child);
                    q.add(child);
                }
            }
        }
        
        return false;
    }
}

DFS


public class Solution {

    private boolean ret = false; 
     
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {

        HashSet<DirectedGraphNode> set = new HashSet<>();
        set.add(s);
        
        
        dfs(graph, s, t, set);
        return ret;
    }
    
    
    void dfs( ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, 
              DirectedGraphNode t, HashSet<DirectedGraphNode> set ){
        
        if ( s == t){
            ret = true;
            return;
        }
        
        for( DirectedGraphNode neighbor : s.neighbors){
            if ( set.contains(neighbor)){
                continue;
            }
            
            set.add(neighbor);
            dfs( graph, neighbor, t, set);
            set.remove(neighbor);
        }
    }
}


</code></pre>






<div class="comment">
1. BFS or DFS 图里面搜索一般用BFS.  <br>
2. 此题 DFS为permutation末班， （大容器，小容器，boolean array) 因为此题目没有让返回所有解，所以说不需要大容器，小容器，只用一个hashset去重，保证路径不会原路返回。<br>
   注意此题用了一个全局变量表示结果，因为dfs不返回值，所以当找到了，就在外面记录<br>
</div>




</body>
