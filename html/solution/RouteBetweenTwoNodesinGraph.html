<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
										   
										   
解决问题？ 无向图两点之间能否联通？    BFS, DFS模板，必背

无向图做BFS,DFS一定要去重， 否则A-> B ， B->A 可以反复递归无法结束。 但是递归结束可以返回上一层。

BFS : Queue + HashSet
public class Solution {

    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {

        
        Queue&lt;DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        HashSet&lt;DirectedGraphNode> set = new HashSet<DirectedGraphNode>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            DirectedGraphNode node = q.poll();
            
            if ( node == t){
                return true;
            }
            
            for( DirectedGraphNode child : node.neighbors){
               
               if ( set.contains(child) ){
                   continue;
               }
                    
               set.add(child);
               q.add(child);
            }
        }
        
        return false;
    }
}

DFS  HashSet 对点去重( 这个模板要熟背诵，这是很多题目的基础函数)
<li><a href="solution/RedundentConnection.html">Redundant Connection （无向图找环）</a> <a href="https://leetcode.com/problems/redundant-connection/description/">Q</a>  </li>


public class Solution {

    private boolean ret = false; 
     
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {

        HashSet<DirectedGraphNode> set = new HashSet<>();
		
        set.add(s);
        dfs(graph, s, t, set);
		set.remove(s);                                                 // 当最高层的DFS返回时，要把原来的start,清零。 不然多次DFS会出错。
		
        return ret;
    }
    
    
    void dfs( ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, 
              DirectedGraphNode t, HashSet<DirectedGraphNode> set ){
        
        if ( s == t){
            ret = true;
            return;
        }
        
        for( DirectedGraphNode neighbor : s.neighbors){                                     CADR : continue, add, DFS, remove
            if ( set.contains(neighbor)){
                continue;
            }
            
            set.add(neighbor);
            dfs( graph, neighbor, t, set);
            set.remove(neighbor);
        }
    }
}

图的遍历事件复杂度对于DFS, BFS都是 O(m+n)  ~= O(m) ~= O(n^2), where m is the number of edge and n is number of vertex










有向图一般是对边去重，断边加边， 不用Set。 但是此题对点去重也可以对。
参见例题 <li ><a href="solution/reconstructitinerray.html">Reconstruct Itinerary(有向图DFS搜索某种路径：断边法)</a> <a href="https://leetcode.com/problems/reconstruct-itinerary/description/">Q</a>  </li>


public class Solution {

    private boolean ans = false; 
    
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {
        
           dfs(s, t);
           return ans;
    }
    
    public void dfs( DirectedGraphNode s, DirectedGraphNode t){
        if ( s == t){
            ans = true;
            return;
        }
        
        for( int i=0; i<s.neighbors.size(); i++){
            DirectedGraphNode n = s.neighbors.get(i);
            s.neighbors.remove(i);
            dfs(n, t);
            s.neighbors.add(i, n);
        }
    }
    
}




棋盘类DFS模板, 用boolean array去重

void dfs( start, matrix){

    1. 递归的结束条件 （ 一般是越界，或者撞墙，或者访问过的）
	
	2. 递归达到某种要求（走到某点， 返回 ）
	
	3. 标记为访问过，如果连续走，可以直接mark图，否则用boolean array不破坏图 
	
	4. 找到下一层的所有坐标，分别做DFS broadcast
}





棋盘类BFS模板 HashSet + Queue

 public boolean hasRoute(int[][] board, int[] start, int[] destination) {

        int code = i * col + j;
		
        Queue&lt;Integer> q = new LinkedList<Integer>();
        HashSet&lt;Integer> set = new HashSet<Integer>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            int n = q.poll();
            
			int x = n/col;
			int y = n%col;
			
            if ( x == a && y == b){                // 判断结束条件 
                return true;
            }
            
            // 对下一步的每一种可能性进行三个标准判断，如果可以则加入
		   
            if ( 过界， 撞墙，没有访问过 ）   
               set.add(child);
               q.add(child);
            }
			
			if ( 过界， 撞墙，没有访问过 ）  
               set.add(child);
               q.add(child);
            }
			
        }
        
        return false;
    }




Google 面试题目： 能不能从一点走到另外一点， 
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。

BFS解法
class Node{
int x;
int y;

}
void BFS(int x, int y, int m, int n){

     Queue<Node> q = new LinkedList<>();
	 HashSet<Node> set = new HashSet<>();
	 
	 
	 q.add(new Node(x,y));
	 set.add(new Node(x,y);
	 
	 while( ！q.isEmpty（））{
	     Node node = q.poll();
		 
		 if （ node.x == m, && node.y  == n ){
		      return true;
		 }
		 
		 if ( 2*node.x <= m && node.y <= n && 判断 (2*n.x, n.y)未访问过 ){
		     q.add(new Node(2*n.x, y);
		     set.add(new Node(2*n.x, y));
		}
		 
		 if ( n.x <= m && 2n.y<= m && 判断 （n.x, 2*n.y)未被访问过 ){
		     q.add(Node(n.x, 2*n.y(;
		     set.add(Node(n.x, 2*n.y);
		 }
	 }
     
	 return false;
}


DFS 解法 
boolean ans = false;

void DFS(int x, int y, int m, int n， boolean[][] visited){

	if ( x > m || y > n || visited[x][y] ){
	    return;
	}
	
    if ( x == m && y == n ){
	    ans = true;
		return;
	}
	
    visited[x][y] = 1;

    DFS(2x, y, m, n);                                                    
	DFS(x, 2y, m, n);
}




</code></pre>








<div class="comment">
1. BFS or DFS 图里面搜索一般用BFS. 有时候DFS比BFS要好写些。 <br>
</div>




</body>
