<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
BFS
public class Solution {

    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {

        
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        HashSet<DirectedGraphNode> set = new HashSet<DirectedGraphNode>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            DirectedGraphNode node = q.poll();
            
            if ( node == t){
                return true;
            }
            
            for( DirectedGraphNode child : node.neighbors){
               
               if ( set.contains(child) ){
                   continue;
               }
                    
               set.add(child);
               q.add(child);
            }
        }
        
        return false;
    }
}

DFS


public class Solution {

    private boolean ret = false; 
     
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {

        HashSet<DirectedGraphNode> set = new HashSet<>();
        set.add(s);
        
        
        dfs(graph, s, t, set);
        return ret;
    }
    
    
    void dfs( ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, 
              DirectedGraphNode t, HashSet<DirectedGraphNode> set ){
        
        if ( s == t){
            ret = true;
            return;
        }
        
        for( DirectedGraphNode neighbor : s.neighbors){                                     CADR : continue, add, DFS, remove
            if ( set.contains(neighbor)){
                continue;
            }
            
            set.add(neighbor);
            dfs( graph, neighbor, t, set);
            set.remove(neighbor);
        }
    }
}

Google 面试题目： 能不能从一点走到另外一点， 
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。

BFS解法
class Node{
int x;
int y;

}
void BFS(int x, int y, int m, int n){

     Queue<Node> q = new LinkedList<>();
	 q.add(new Node(x,y));
	 
	 while( ！q.isEmpty（））{
	     Node node = q.poll();
		 
		 if （ node.x == m, && node.y  == n){
		      return true;
		 }
		 
		 if ( 2*node.x <= m && node.y <= n)
		     q.add(Node(2*n.x, y);
		 
		 if ( n.x <= m && 2n.y<= m)
		     q.add(Node(n.x, 2*n.y(;
	 }
     
	 return false;
}


DFS 解法 
boolean ans = false;

void DFS(int x, int y, int m, int n){        
    if ( x == m && y == n ){
	    ans = true;
		return;
	}
	
	if ( x > m || y > n ){
	    return;
	}

    DFS(2x, y, m, n);                                                         CADR : 因为不可能重复，所以不需要set, 就没有contiue, add, remove, 只剩下DFS了 
	DFS(x, 2y, m, n);
}




</code></pre>


DFS模板：<br>
什么时候用DFS : 能否在图中一点走到另外一点，且求出这条路径的权重，这种题目只能用DFS解答, <br>

void DFS(){<br>

   if (){<br>
       递归的结束条件   I<br>
   }<br>

   递归的分解           II<br>
}<br>


1. 注意的是图里面的DFS要用去重。<br>
2. 如果DFS的图是无限大的，你要强行加上结束条件，如上题。<br><br><br>







<div class="comment">
1. BFS or DFS 图里面搜索一般用BFS. 有时候DFS比BFS要好写些。 <br>
</div>




</body>
