<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
BFS
public class Solution {

    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {

        
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        HashSet<DirectedGraphNode> set = new HashSet<DirectedGraphNode>();
        
        q.add(s);
        set.add(s);
        
        while( !q.isEmpty() ){
            DirectedGraphNode node = q.poll();
            
            if ( node == t){
                return true;
            }
            
            for( DirectedGraphNode child : node.neighbors){
               
               if ( set.contains(child) ){
                   continue;
               }
                    
               set.add(child);
               q.add(child);
            }
        }
        
        return false;
    }
}

DFS


public class Solution {

    private boolean ret = false; 
     
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, DirectedGraphNode t) {

        HashSet<DirectedGraphNode> set = new HashSet<>();
        set.add(s);
        
        
        dfs(graph, s, t, set);
        return ret;
    }
    
    
    void dfs( ArrayList<DirectedGraphNode> graph, DirectedGraphNode s, 
              DirectedGraphNode t, HashSet<DirectedGraphNode> set ){
        
        if ( s == t){
            ret = true;
            return;
        }
        
        for( DirectedGraphNode neighbor : s.neighbors){
            if ( set.contains(neighbor)){
                continue;
            }
            
            set.add(neighbor);
            dfs( graph, neighbor, t, set);
            set.remove(neighbor);
        }
    }
}

Google 面试题目： 能不能从一点走到另外一点， 
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。

BFS解法
class Node{
int x;
int y;

}
void BFS(int x, int y, int m, int n){

     Queue<Node> q = new LinkedList<>();
	 q.add(new Node(x,y));
	 
	 while( ！q.isEmpty（））{
	     Node node = q.poll();
		 
		 if （ node.x == m, && node.y  == n){
		      return true;
		 }
		 
		 if ( 2*node.x <= m && node.y <= n)
		     q.add(Node(2*n.x, y);
		 
		 if ( n.x <= m && 2n.y<= m)
		     q.add(Node(n.x, 2*n.y(;
	 }
     
	 return false;
}


DFS 解法 
boolean ans = false;

void DFS(int x, int y, int m, int n){
    if ( x == m && y == n ){
	    ans = true;
		return;
	}
	
	if ( x > m || y > n ){
	    return;
	}

    DFS(2x, y, m, n);
	DFS(x, 2y, m, n);
}




</code></pre>


DFS，BFS都能解决是否能从图中一点走到另一点， 有时候DFS更简单，熟练理解DFS



<div class="comment">
1. BFS or DFS 图里面搜索一般用BFS.  <br>
2. 此题 DFS为permutation末班， （大容器，小容器，boolean array) 因为此题目没有让返回所有解，所以说不需要大容器，小容器，只用一个hashset去重，保证路径不会原路返回。<br>
   注意此题用了一个全局变量表示结果，因为dfs不返回值，所以当找到了，就在外面记录<br>
</div>




</body>
