<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>

<pre><code>
  Solution I:: 遍历的写法

  class Solution {
      int count = 0;
      int saveSum = 0;
      public int pathSum(TreeNode root, int sum) {
          if ( root == null) return 0;

          saveSum = sum;

          helper(root);
          return count;
      }

      void helper(TreeNode root){     // preOrder写法遍历每一个点， 把print换成DFS往里面套。这里preOrder, postOrder and inOrder都可以, 三种遍历方法都可以
          if ( root == null) return;

          dfs(root, saveSum - root.val);

          helper(root.left);
          helper(root.right);
      }


      // 从顶点往下求和

      void dfs(TreeNode root, int sum){
          if ( sum == 0){
              count++;
          }

          if ( root.left != null){
              dfs(root.left, sum - root.left.val);
          }

          if ( root.right != null){
              dfs(root.right, sum- root.right.val);
          }
      }
  }

  // 遍历模板背诵：递归套递归
  int count = 0;
  int pathCount(TreeNode root){
    if ( root == null ) return 0;

    helper(root);
    return count;
  }

  //遍历所有的顶点，每个顶点做一次DFS。 这里用inorder, preorder, postorder都可以
  helper(root){
      if (root == null) return;

      dfs(root, saveSum - root.val);

      helper(root.left);
      helper(root.right);
  }


  // 从每个顶点往下求和
  dfs(TreeNode root, int sum){
       if ( sum == 0){
         count++;
       }

       if (root.left != null){
         dfs(root.left, sum - root.left.val);
       }

       if ( root.right != null){
          dfs(root.right, sum-root.right.val);
       }
  }

Solution II: divide and conquer(分治套分治，加的逻辑)
class Solution {
    int saveSum = 0;
    public int pathSum(TreeNode root, int sum) {
        if ( root == null) return 0;

        saveSum = sum;

        return helper(root);
    }

    int helper(TreeNode root){
        if ( root == null) return 0;

        return dfs(root, saveSum - root.val) +
               helper(root.left)+
               helper(root.right);
    }

    int dfs(TreeNode root, int sum){
        int temp = sum == 0? 1 : 0;

        if ( root.left != null){
            temp = temp + dfs(root.left, sum - root.left.val);
        }

        if ( root.right != null){
            temp = temp + dfs(root.right, sum- root.right.val);
        }
        return temp;
    }

</code></pre>





<div class="comment">
Time complexity :   O(n^2)   <br>
Space complexity :     <br>
</body>
