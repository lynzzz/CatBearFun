<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
This is similar to kNight Dialer.
DFS brute force => DFS memorization => DP


Solution 1: DFS brute force(会写DFS暴力很重要，至少是weak hire)

class Solution {
    public int numWays(int steps, int arrLen) {
        return dfs(steps, arrLen, 0, 0);
    }

    int dfs(int steps, int arrLen, int curStep, int curPos){
        if ( curPos < 0 || curPos == arrLen){
            return 0;
        }

        if ( curStep == steps){
            if ( curPos == 0){
                return 1;
            }else{
                return 0;
            }
        }

        int total = 0;

        total = total + dfs(steps, arrLen, curStep+1, curPos-1);
        total = total + dfs(steps, arrLen, curStep+1, curPos+1);
        total = total + dfs(steps, arrLen, curStep+1, curPos);

        return total;
    }
}

n*2^n where n is step

Solution II: DFS + memorization
class Solution {
    int modulo = (int)Math.pow(10,9) + 7;
    public int numWays(int steps, int arrLen) {

        Integer[][] dp = new Integer[steps+1][arrLen];

        return dfs(steps, arrLen, dp, 0, 0);
    }

    int dfs(int steps, int arrLen, Integer[][] dp,  int step, int curPos){
        if ( curPos < 0 || curPos == arrLen){
            return 0;
        }

        if ( dp[step][curPos] != null){
            return dp[step][curPos];
        }

        if ( step == steps){
            if ( curPos == 0){
                return 1;
            }else{
                return 0;
            }
        }

        int total = 0;

        total = (total + dfs(steps, arrLen, dp, step+1, curPos-1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos+1))%modulo;
        total = (total + dfs(steps, arrLen, dp, step+1, curPos))%modulo;

        dp[step][curPos] = total;

        return total;
    }
}

step * length

1. 跳棋模型： 给定步数和走法限制，求多少种走法。
2. DFS带两参数: curStep, curPos.
3. 很容易优化成DFS + memorization




</body>
