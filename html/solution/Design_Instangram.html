<html>
<body>



<pre><code>

  <li><a href="https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG">Designing Instagram (grokking system design)</a>  </li>
1. Storage

Storage for photo:
say everyday 2m photos created and average photo size 200kb, total storage is 2m * 200kB = 400 * 10^9Byte = 400GB.
one day we need 400GB disk, and one month, we need 12TB disk, so photos cannot be stored in one machine, what we need is
distributed file storage such as S3.

storeage for table
image table:
id 4byte + user id 4byte + title 50byte + createdAt 50 byte + image path = 256Byte = 364 Byte
364Byte * 2m = 0.7G per day, 21GB per month. 240GB per year.

user table:
id 4Byte + name 20byte + email 50byte + created At 4Byte + last login 4Byte = 82byte
say there is 500M user. total size = 82 Byte * 500M = 40GB

Friendship table:
id 4byte, from 4 byte, to 4 byte, total 12byte
500M users, each user follow 100 user, total = 500M * 100 * 12byte = 0.6TB.

QPS:
say there are 500M user, 1M daily active user, each user does 10 read operation per day.
say there are 500M daily active user, each user does 1 write operation per day.

Read QPS = 1M * 10/86400 = 100.
Write QPS = 10

Bandwidth:
bandwidth = QPS * average size/per request or response
if average size per response 2M

outgoing bandwidth = 100 * 2M = 200M/s

Table schema:
User table
id          int PK
name        varchar(25)
email       varchar(30)
updatedAt   timestamp
createdAt   timestamp

photo table
id        int  PK
userId    int  FK
title     varchar(50)
createdAt timeStamp
ImagePath varChar(50)


frinedship table
id    int PK
from  int
to    int

Generate News feed for sam whose user id is 1

select photo.title, photo.user_id, photo.createdAt from
(select * from friendship where from_user = 1) as f
left join photo
on f.to_user = photo.user_id
order by photo.createdAt;




// Sql statment to creat table and insert value
 create database ins  // create database
 use ins// use database

 // create user table
create table user(id int not null auto_increment, name varchar(50) not null, email varchar(50), primary key (id));
 // insert value;
 insert into user (name, email) values ("Lyn", "lzengzeng22@gmail.com");
insert into user (name, email) values ("Mark", "mark@gmail.com");
insert into user (name, email) values ("Jay", "mark@gmail.com");
insert into user (name, email) values ("NanXia", "Nan@gmail.com");
insert into user (name, email) values ("Jing", "Jing@gmail.com");

// create friendship table;
create table friendship(id int not null auto_increment, from_user int not null, to_user int not null, primary key (id));
insert into friendship (from_user, to_user) values (1, 2);
insert into friendship (from_user, to_user) values (1, 3);
insert into friendship (from_user, to_user) values (1, 3);
insert into friendship (from_user, to_user) values (2, 5);

// create photo table
create table photo(id int not null auto_increment primary key, user_id int not null, title varchar(100) not null, image_path varchar(50) not null, createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP );
insert into photo (user_id, title, image_path) values (3, "Japan photo", "Azure/Jay");
insert into photo (user_id, title, image_path) values (2, "California San Diego photo", "Azure/Mark");
insert into photo (user_id, title, image_path) values (3, "Cancun trip", "Azure/Jay");




// Query to get user 1 的 News feed

select photo.title, photo.user_id, photo.createdAt from
(select * from friendship where from_user = 1) as f
left join photo
on f.to_user = photo.user_id
order by photo.createdAt;

此处还可以用NOSQL DB 来存用户和照片的关系, 哪个用户拥有哪些照片, 这样的话就不用像上面那样sql语句做join between Photo table和user table做Join
key: userID
value: List of photo ID the user owns。
2->{100,101}
3->{102,103}


// Optimization to create index on photo id and photo creation time.
create index idx_on_photo_id_and_creationTime on photo(id, createdAt);

2. reliability and Redundency
  1. Problem with one single storage server: Single point failure
  2. Solution: creating replica,
  3. when one server fails, the trafic will be routed to the remaining ones, which is called fail-over



3.Web server optimization:
  Knowledge: Web server has connection limit, which I think is QPS limit, typically one webserver can handle 1000 QPS.

  Write goes to disk, it is slow. "read" cannot be serverd if web server is busy with all write requests.
  solution: Have dedicated servers for read and different servers for write that update doesn't hog the web server.


4. Data Partition: (Horizontal partition, 横着分)
  Partition phto table:
  Approach 1: partition by user ID. say you have 10 servers, server number can be obtained by user_id%10. that way, all photos of a user
              are saved in one partition. In partition photo table, primary photo id will be different from original one and is auto-incremented.

          for example, partition the photo table by user ID, userID%2
          original photo table:
          photoID     userId     content
             1           201      dog
             2           201      cat
             3           200      tree
             4           200      people
             5           201      male
             6           202      female

          partition table 1                                 partition table 2
          photoID        userID  content                    photoID        userID    content
             1            200      tree                       1               201      dog
             2            200      people                     2               201      cat
             3            202      female                     3               201      male


  Drawback: a. QPS: hot user, lady gaga, a lot of user see her picture, QPS load of that partition is high.
            b. Storage: if a user has too many pictures, the distribution is not uniform.
            c. Single point failure: if this partition is down, all photos of some user will be unavailable.

  Data Migration: old data, each entry in photo table has user_id, it maps to a partition, that partition auto increment and add the new entry in.
                  new generated data: new data also has user_id, that maps to a partition, do auto_increment in that shard.
                  example: user id 700 content aloha, it maps to shard 1.
                  photoId    userID  content
                     4        700     aloha.



   Approach II: partition by photoID:
           old photo entry can be mapped to the crosponding shard, but the challenge is new photo doesn't come with an photo ID, you don't know which shard it maps to. We need to have a dedicated database generating global photo id,
           we can set up a database table to generate auto-incremented photo ID.

           And then you map global photo id to a shard, add the entry into the shard key.
           The shard table should not use auto-incremented ID as primary ID, it should use global photo id as primary key.

               global ID table
           Image ID:
           1
           2
           3
           4
           5
           6

           parition 1                                            partition 2
           photo ID   userID    content              photo ID       user ID       content
            1          201         dog                  2             201          cat
            3          200         tree                 4             200          table
            5          201         male                 6             202          female

  Follow up Question: Single point failure on this key-generation db


</code></pre>




</body>



</html>
