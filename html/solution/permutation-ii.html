<html>
<body>
<pre><code class="">


class Solution {
       public List<List<Integer>> permuteUnique(int[] nums) {
        
        Arrays.sort(nums);    // 开始必须要排序, 不然去duplicate逻辑不对.
        List&lt;List<Integer>> results = new ArrayList<>();        
        dfs(results, new ArrayList<>(), nums, new boolean[nums.length]);
        return results;
    }
    
    
    public void dfs(List&lt;List<Integer>> results, List<Integer> result, int[] nums, boolean[] visited){
        
        if ( result.size() == nums.length){
            results.add(new ArrayList<Integer>(result));
            return;
        }
        
        for( int i=0; i&lt;nums.length; i++){
            if( visited[i]){
                continue;
            }
            
            if ( i>=1 &&  nums[i] == nums[i-1] && !visited[i-1] ){
                continue;
            }
            
            result.add(nums[i]);
            visited[i] = true;
            dfs(results,result, nums, visited);
            result.remove(result.size()-1);
            visited[i] = false;
        }
    }
}

模型为以下， 每层都一样，所以需要visited[i]保征每个位置只能取一次，和重复的处理方法

12245
12245
12245
12245
12245



1. 用一个boolean array 来根据index位置去重。

这里有个技巧，初始化的时候用简单类型，每个元素自动初始化为false
boolean[] index = new boolean[size];


</code></pre>
</body>


</html>
