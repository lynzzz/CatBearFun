<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>

    class Solution {
        List<String> ret = new ArrayList&lt;>();
        HashMap<String, List&lt;String>> m = new HashMap&lt;>();
        
        public List<String> findItinerary(List<List<String>> tickets) {
                            
            for(List<String> ticket : tickets){
                String from = ticket.get(0);
                String to = ticket.get(1);
                m.putIfAbsent(from, new ArrayList<String>());
                m.get(from).add(to);
            }
            
            for(String key : m.keySet()){
                List<String> Desti = m.get(key);
                Collections.sort(Desti);
                m.put(key, Desti);
            }
            
            ret.add("JFK");
            dfs(tickets, "JFK");
            
            return ret;
        }
        
        
        void dfs(List<List<String>> tickets, String from){
            
            if ( ret.size() == tickets.size() + 1){
                return;
            }
            
            if ( !m.containsKey(from)) return;
            
            for(int i=0; i<m.get(from).size(); i++){
                String dest = m.get(from).get(i);
                
                ret.add(dest);
                m.get(from).remove(i);
                
                dfs(tickets, dest);
                
                if ( ret.size() == tickets.size() + 1){
                    return;
                }            
                
                ret.remove(ret.size()-1);
                m.get(from).add(i, dest);
            }
        }
    }

无向图和有向图的区别：

无向图  1--2，  只有一条边在1，2之间，    所以DFS开始走的时候从1到2，然后从2继续往下遍历的时候，2可能原路返回1，所以我们会用一个HashSet防止顶点被重复遍历，否则是无限递归

有向图  1<->2,  有两条独立边，1->2, 2->1, 所以DFS开始走的时候从1到2， 然后从2继续往下遍历的时候，是可以通过下一层递归到达1的。              顶点可以被反复遍历，但是边不能被反复遍历，否则无限地归 (这里要注意的问题是 1->2, 2->1后，要防止1->2这条边被再次使用用来做下一次递归)

                
				

		        

时间复杂度：
递归有N层，每层N-1个选择，遍历次数N^N
总的时间复杂度为 O(N^N)

空间复杂度：
O(e+N) ，O(e)为存边的空间， O(N)为递归栈的开销





</body>
