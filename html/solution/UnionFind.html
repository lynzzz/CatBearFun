Union Find( disjoint set, 并查集）<br><br>
应用：无向图节点分类<br>
uf.union(A, B), 接口take两个节点


<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">Number of connected components in an undirected graph</a>  </li>
<li><a href="solution/RedundentConnection.html">Redundant Connection</a> <a href="https://leetcode.com/problems/redundant-connection/description/">Q</a>  </li>



算法：   Step 1 : 图里的每一个点是一个独立的集<br>
        step 2 : 按照你自己定义的法则进行合并。<br><br>



数据结构 :  hashmap <br>
函数     ：
            constructor<br>
            find: 返回这个节点的root<br>
            union: 合并这两个节点的根节点,  每union(A, B)一次，和两个点就归为一类,  时间复杂度近似O(1)
<pre><code>


简单版本：
class UF
{
    int[] parent = new int[10000];

    UF(){
        for( int i=0; i&lt;10000; i++){
            parent[i] = i;
        }
    }

    int find(int node){
        if ( parent[node] == node){
            return node;
        }
        return find(parent[node]);
    }

    void union(int n1, int n2){
        int p1 = find(n1);
        int p2 = find(n2);
        parent[p1] = p2;
    }


}



复杂版本：带rank

class UF{

int[] parent;
int[] rank;

      UF(){
        for( int i=0; i&lt;10000; i++){
            parent[i] = i;
            rank[i] = 0;
        }
	  }


	  private int find( int node ){
	       if ( parent.get(node) == node ){
		      return node;
		   }
	       return find( parent.get(node));
	  }

	  public void union( int node1, int node 2){

	    int root1 = find(node1);
			int root2 = find(node2);

			if ( rank[root1] > rank[root2] ) ){
			    parent[root2] = root1;
			}else if ( rank[root1] < rank[root2] ){
			    parent[root1] =root2;
			}else{
			    parent[root1]= root2;
			    rank[root2]++;
			}
	  }

}

</code>
</pre>
