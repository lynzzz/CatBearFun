<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>

  <pre><code>
1. ^ logic XOR operator: 0 if the same, 1 if different

a^a = 0
a^0 = a
a^b^c = a^c^b  (交换律)

2.~ logic not operator:
32个bit, 每一bit都取反

a &amp; ~a = 0


3. | logic or operator: 1 if any of the two is 1. 0 if both are 0


4. how to get the negative value of original value using bit operator
int a=2
 ~a + 1 => -a => -2

 int b = -3;
 ~b + 1   => -b = 3


5. Java build in function
 String Integer.toBinaryString(int n);
 int    Integer.bitCount(int n);

6. Skill
 2^n = 1<< n

 A &amp; 0 = 0

&amp; precedence is lower than ==

n &amp; bitmast == 1,    == takes precedence first. need to change to  (n &amp; bitmast) == 1



7. >> 带符号右移，原来是0，左边加0. 原来是1，左边加1
int a= 10  （1010）     a>>2 0010
int a=-2    11111111 11111111  11111111 11111110
a>>8        11111111 11111111  11111111 11111111

>>>无符号右移
a=-2, a>>>8 00000000 11111111  11111111 11111111

常用技巧1: 判断bit每一位的值, 左移右移都可以。 常见题目： （求1的个数，两个integer bitwise comparision）
//左移的解法。 Azure storage 面试的时候算法是想出来的，但是实现是错误的，还是不熟练，当然那个面试官也没看出来，他也不熟练。
这个解法要把它背下来。

int count = 0;
int temp = 1;
for( int i=0; i&lt;32; i++){
  if (( temp&n) != 0 ){
    count++;
  }
  temp = temp<&lt;1;
}
return count;


//右移的解法。
int count = 0;
for(int i=0; i<32; i++){
   if (( n & 1) == 1){
       count++;
   }
   n = n>>1;
}
return count;

1178. Number of Valid Words for Each Puzzle
for（int i=31; i>=0; i--){
  int LastBit1 = (n1>>i)&amp;1;
  int lastBit2 = (n2>>i)&amp;1;
  if ( business logic){
      return true;
  }
  return false;
}


1178. Number of Valid Words for Each Puzzle
常用技巧2: 构造数  count =0  count = (1&lt;&lt;i) | count

无重复字母的字符串用bitmask表示方法
int bitmask = 0;
for(char c : s.toCharArray()){
    int shift = c - 'a';
    bitmask  = (1&lt;&lt;shift) | bitmask;
}
return bitmaskt



常用技巧3:  int bitmask = 0;,  bitmask = bitmask^c;
int bitmask =0;
for( char c : string){
  bitmask = bitmask^c
}

注意事项：
1. 'A'的ASCII码在'a'之前， 'A'是65，'a'是97
2. 如果用Bitwise Operator表示一个即有大写字母又有小写字母的字符串时候，基准值是ASCII比较小的‘A’。
3. 位移量最高可达到 ‘z’ - ’A‘ = 122 - 65 = 57  只有32位的int是无法解决这个问题的，必须用64位的long。
4. 系统默认的整数的数据类型是int, 1&lt;&lt;shift, 当shift=31的时候，会返回-1，后面的值都不对了， 所以必须把1赋成long, 在进行左移.

long bitmask = 0;
long start = 1;

for(char c : s.toCharArray()){
    bitmask = (start&lt;&lt;c - 'A') | bitmask;  // 如果此行写成 1&lt;&lt;shift, 当shift=31的时候，会返回-1，后面的值都不对了， 所以必须把1赋成long.

}

return bitmask.


5. team transfer inteview 2/12
Round II: 2/12: Rushi
You have a file that has a lot of numbers ranging from [0, 32000], assuming there is no duplicate, you have an interface to read from file int getNumber(), and another interface to write the number to a file. Can you write the numbers to file in sorted order?

Worst case memory for loading the number:
4byte * 32000 = 128kb.开始没有理解是什么意思，他的意思是范围是0-32000,没有重复， 最坏的可能性里面有32000个数。

Q:Sort complexity?
A:O nlgn, merge sort, 要求更快到O(n)

hint: 你知道了整数的范围：
A: booloean[] arr = new boolean[32000];
scan once set the boolean. scan another time ,check true and print it out to new file.
Time complexity O(n),

I: good, ok with time complexity O(n), how much memory do you need？
1byte * 32000 = 32000byte. can you use less than that?

me: priority queue,
I: time O(nlgn)

me: B+ tree
I: time still O(nlgn).

I: can you use less memory other than boolean array.
me: I got it, using bit vector,
that way, 1 byte has 8 bits, we can use 4000byte to represent. use byte index + offset to represent a number,
if there exists a number, set it to 1, otherwise, set it to 0.

I: good can you write code?
// set array
int temp = 1;
   temp = temp<&lt;offSet;
   arr[i] = temp | arr[i]

// write
for(int i=0; i&lt;4000; i++){
  boolean b = arr[i];
  for（int j=0; j&lt;8; j++){
       int temp = 1;
       temp = temp<&lt;j;
       if ( temp & b != 0){
         print(i*4000 + j);
       }
  }
}

2/15 回家发现这种做法是错的
boolean b1 = false;
  b&1  // 这种写法编译不了，必须左右两边类型相同。左边是boolean, 右边是int
存储类型应该是char[] arr = new char[4000], char 初始值是0.

Bitwise operator
 1. 只能用到primitive type(int, long, char)
 2. 左右两边类型必须相同。
 3. 算法题中最常见的就是int and char, char 在内存中表示是ASCII [0-255]。
    你要分一个byte用char, 8 bits, 不能用boolean
     你要分4个byte用int, 32bits

如何对bit赋值用？ 三步。熟练背诵


Step1: get a interger 1
Step 2: shif this integer to offset positions
Step3:   Do bitwise operator '|' with original value and then assign it to original value.

// Code below
 int temp =1;
 temp = temp<&lt;offset;
   n = temp | n

对bit赋值的题目：
<li><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/">onvert-binary-number-in-a-linked-list-to-integer</a>  </li>




如何Check bit 1？  用 '&amp;'： 熟练背诵
Step1: int temp =1
Step2: for loop    if ( ( temp & n) != 0)
Step3: temp = temp<&lt;1;

int temp =1;
for( int i=0; i&lt;8; i++){
   if( ( temp &amp; n) != 0){
       // this bit is 1
   }
   temp = temp<&lt;1;
}

Check bit 每一位值的题目：
<li><a href="https://leetcode.com/problems/hamming-distance/">Hamming distance</a>  </li>
<li><a href="https://leetcode.com/problems/number-of-1-bits">Number of 1 in bit</a>  </li>



</code></pre>


</body>
