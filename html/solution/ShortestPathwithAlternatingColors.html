<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>
解题要点：
1. 建图的时候把颜色带上。  HashMap<Integer, List<int[]>>， 第二个参数存颜色。
2. HashSet去重的时候也得把颜色带上， 没有想出来这个，有些test case过不去，骚套路！
3. 图里面的最短路径，优先考虑用BFS求解，DFS有可能爆栈或者超时。

Try I: DFS without hashet, 解法是错误的， 1<->2 永远走不出来，死循环。
n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]

class Solution {
    int ret = Integer.MAX_VALUE;

    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        HashMap&lt;Integer, List&lt;int[]>> m = new HashMap&lt;>();
        for( int i=0; i&lt;n; i++){
            m.put(i, new ArrayList&lt;int[]>());
        }

        for(int[] redEdge : red_edges){
            int from = redEdge[0];
            int to = redEdge[1];
            m.get(from).add(new int[]{to, 0});  // 0 is red
        }

        for(int[] blueEdge : blue_edges){
            int from = blueEdge[0];
            int to = blueEdge[1];
            m.get(from).add(new int[]{to, 1});
        }

        int[] ans = new int[n];
        ans[0] = 0;

        for( int i=1; i&lt;n; i++){
            dfs(0, i, -1, m, 0);
            ans[i] = ret == Integer.MAX_VALUE ? -1: ret;
            ret = Integer.MAX_VALUE;
        }
        return ans;
    }

    void dfs(int cur, int target, int curColor, HashMap&lt;Integer, List&lt;int[]>> m, int step){
        if ( cur == target){
            ret = Math.min(step, ret);
            return;
        }

        if ( m.get(cur).size() == 0){
            return;
        }

        for(int[] i : m.get(cur)){

            int nextColor = i[1];
            if ( nextColor == curColor){
                continue;
            }

            dfs(i[0], target, nextColor, m, step+1);
        }
    }
}

try II : DFS + Hashset, hashset里面没有存颜色，有testcase过不了，因为一个点，可以红边指向它，也可以蓝边指向它，如果过了一次就不在访问，
就会让一个点不同颜色边过两次的解法给滤掉。
class Solution {
    int ret = Integer.MAX_VALUE;

    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        HashMap&lt;Integer, List&lt;int[]>> m = new HashMap&lt;>();
        for( int i=0; i&lt;n; i++){
            m.put(i, new ArrayList&lt;int[]>());
        }

        for(int[] redEdge : red_edges){
            int from = redEdge[0];
            int to = redEdge[1];
            m.get(from).add(new int[]{to, 0});  // 0 is red
        }

        for(int[] blueEdge : blue_edges){
            int from = blueEdge[0];
            int to = blueEdge[1];
            m.get(from).add(new int[]{to, 1});
        }

        int[] ans = new int[n];
        ans[0] = 0;

        for( int i=1; i&lt;n; i++){
            dfs(0, i, -1, m, new HashSet&lt;Integer>(), 0);
            ans[i] = ret == Integer.MAX_VALUE ? -1: ret;
            ret = Integer.MAX_VALUE;
        }
        return ans;
    }

    void dfs(int cur, int target, int curColor, HashMap&lt;Integer, List&lt;int[]>> m, HashSet&lt;Integer> set, int step){
        if ( cur == target){
            ret = Math.min(step, ret);
            return;
        }

        if ( m.get(cur).size() == 0){
            return;
        }

        for(int[] i : m.get(cur)){

            int node = i[0];
            int color = i[1];

            if ( node == cur){
                continue;
            }

            if ( set.contains(node)){
                continue;
            }

            if ( color == curColor){
                continue;
            }

            set.add(node);
            dfs(node, target, color, m, set, step+1);
            set.remove(node);
        }
    }
}

try III : DFS + HashSet 记录点+颜色 ： TLE
class Solution {
    int ret = Integer.MAX_VALUE;

    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        HashMap&lt;Integer, List&lt;int[]>> m = new HashMap&lt;>();
        for( int i=0; i&lt;n; i++){
            m.put(i, new ArrayList&lt;int[]>());
        }

        for(int[] redEdge : red_edges){
            int from = redEdge[0];
            int to = redEdge[1];
            m.get(from).add(new int[]{to, 0});  // 0 is red
        }

        for(int[] blueEdge : blue_edges){
            int from = blueEdge[0];
            int to = blueEdge[1];
            m.get(from).add(new int[]{to, 1});
        }

        int[] ans = new int[n];
        ans[0] = 0;

        for( int i=1; i&lt;n; i++){
            dfs(0, i, -1, m, new HashSet&lt;String>(), 0);
            ans[i] = ret == Integer.MAX_VALUE ? -1: ret;
            ret = Integer.MAX_VALUE;
        }
        return ans;
    }

    void dfs(int cur, int target, int curColor, HashMap&lt;Integer, List&lt;int[]>> m, HashSet&lt;String> set, int step){
        if ( cur == target){
            ret = Math.min(step, ret);
            return;
        }

        if ( m.get(cur).size() == 0){
            return;
        }

        for(int[] i : m.get(cur)){

            int node = i[0];
            int color = i[1];

            if ( color == curColor){
                continue;
            }

            String visited = String.valueOf(node) + String.valueOf(color);
            if ( set.contains(visited)){
                continue;
            }

            set.add(visited);
            dfs(node, target, color, m, set, step+1);
            set.remove(visited);
        }
    }
}

Solution: BFS 只需要做一次就可以，因为最先找到的点必然是最小路径
class Solution {

    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        HashMap&lt;Integer, List&lt;int[]>> m = new HashMap&lt;>();
        for( int i=0; i&lt;n; i++){
            m.put(i, new ArrayList&lt;int[]>());
        }

        for(int[] redEdge : red_edges){
            int from = redEdge[0];
            int to = redEdge[1];
            m.get(from).add(new int[]{to, 0});  // 0 is red
        }

        for(int[] blueEdge : blue_edges){
            int from = blueEdge[0];
            int to = blueEdge[1];
            m.get(from).add(new int[]{to, 1});
        }

        int[] ans = new int[n];
        Arrays.fill(ans, Integer.MAX_VALUE);
        ans[0] = 0;

        bfs(m, ans);

        for( int i=0; i&lt;n; i++){
            ans[i] = ans[i] == Integer.MAX_VALUE? -1:ans[i];
        }

        return ans;
    }

    void bfs(HashMap&lt;Integer, List&lt;int[]>> m, int[] ret){
        Queue&lt;int[]> q = new LinkedList&lt;>();
        HashSet&lt;String> set = new HashSet&lt;>();

        set.add(String.valueOf(0) + String.valueOf(-1));
        q.add(new int[] {0, -1});
        int step = 0;

        while( !q.isEmpty()){
            int size = q.size();
            step++;
            for(int i=0; i&lt;size; i++){
                int[] n = q.poll();
                int node = n[0];
                int color = n[1];

                for(int[] neighbor : m.get(node)){
                    int neighborNode = neighbor[0];
                    int neighborColor = neighbor[1];

                    if (color==neighborColor){
                        continue;
                    }

                    String str = String.valueOf(neighborNode) + String.valueOf(neighborColor);

                    if ( set.contains(str)){
                        continue;
                    }

                    ret[neighborNode] = Math.min(step, ret[neighborNode]);

                    set.add(str);
                    q.add(neighbor);
                }
            }
        }
    }
}

</code></pre>
</body>
