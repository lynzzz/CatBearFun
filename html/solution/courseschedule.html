<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>


<pre><code>
public class Solution {
    /**
     * @param numCourses a total of n courses
     * @param prerequisites a list of prerequisite pairs
     * @return true if can finish all courses or false
     */
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // Write your code here

        // construct adjacent list
        HashMap<Integer, ArrayList<Integer>> mapNodeToNeighbors = new HashMap<>();
        for( int i =0; i&lt&prerequisites.length; i++){
            int from = prerequisites[i][0];
            int to = prerequisites[i][1];
            if ( !mapNodeToNeighbors.containsKey(from) ){
                ArrayList<Integer> arr = new ArrayList<>();
                arr.add(to);
                mapNodeToNeighbors.put(from, arr);

            }else{
                ArrayList<Integer> arr = mapNodeToNeighbors.get(from);
                arr.add(to);
                mapNodeToNeighbors.put(from, arr);
            }
        }


        // Construct in-degree array           node - > indegree
        HashMap<Integer, Integer> mapNodeTOIndegree = new HashMap<>();
        for( int i=0; i&lt&prerequisites.length; i++){
            int to = prerequisites[i][1];
            if ( !mapNodeTOIndegree.containsKey(to)){
                mapNodeTOIndegree.put(to, 1);
            }else{
                mapNodeTOIndegree.put(to, mapNodeTOIndegree.get(to) + 1 );
            }
        }
        
        
        // Find all nodes not in degree map, which are start points
        Queue<Integer> q = new LinkedList<>();
        
        for( int i=0; i&lt&numCourses; i++){
            if ( !mapNodeTOIndegree.containsKey(i) ){
                q.add(i);
            }
        }
        
        
        // BFS
        int count = 0;

        
        while( !q.isEmpty() ){
            int temp = q.poll();
            count++;
            
            if ( mapNodeToNeighbors.containsKey(temp) ){
            for(int n : mapNodeToNeighbors.get(temp)){
                    mapNodeTOIndegree.put(n, mapNodeTOIndegree.get(n)-1);
                    if ( mapNodeTOIndegree.get(n) == 0){
                        q.add(n);
                }
            }
            }
        }
        return count == numCourses;
    }   
}


</code></pre>






<div class="comment">
Time complexity :   O(m+n)   <br>


Topological Sorting 不能遍历有环的点， 用遍历的点数和总点数比较有没有环。<br>


Last Time completed at : 6/1/2017 <br>

</div>
</body>
