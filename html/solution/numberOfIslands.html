<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>


<pre><code>
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        
        if ( grid == null || grid.length == 0) return count;
        
        int row = grid.length;
        int col = grid[0].length;
        
        for( int i=0; i&lt;row; i++){
            for( int j=0; j&lt;col; j++){
                if ( grid[i][j] == '1'){
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    
    void dfs(char[][] grid, int i, int j){
        
        int gridRow = grid.length;
        int gridColumn = grid[0].length;
       
        if ( i &lt; 0 || i == gridRow || j&lt;0 || j==gridColumn || grid[i][j] == '0') return;
        
            
        grid[i][j] = '0';
            
        dfs(grid, i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j+1);
        dfs(grid, i, j-1);
    }
}
</code></pre>

<pre><code>

	
public class Solution {

     
    public int numIslands(boolean[][] grid) {
        // Write your code here
        if ( grid == null || grid.length == 0) return 0;
        
        int count = 0;
        
    
        for( int i=0; i&lt;grid.length; i++){
            for( int j = 0; j<grid[0].length; j++){
                if ( grid[i][j]){
                    bfsFill(grid, i, j);
                    count++;
                }
            }
        }
        
        return count;
    }
    
    
    void bfsFill(boolean[][] grid, int i, int j){
        
        int row = grid.length;
        int col = grid[0].length;
        Queue<Integer> q = new LinkedList<>();

        int code = i * col + j;
        
        
        q.add(code);

        
        while ( !q.isEmpty() ){
            
            code  = q.poll();
            i = code/col;
            j = code%col;
            grid[i][j] = false;


            // up 
            if (  (i-1)>=0  && grid[i-1][j]  ){
                q.add(   (i-1) * col + j);
            }
            
            // down
            if ( (i + 1) < grid.length && grid[i+1][j]  ){
                q.add(   (i+1) * col + j );

            }
            
                        
            // left
            if ( (j-1) >= 0 && grid[i][j-1]){
                q.add(i*col + j-1);

            }
            
            // right
            if ( (j + 1) < col && grid[i][j+1] ){
                q.add( i*col + j+1);
            }
        }
    }
}



</code></pre>






<div class="comment">
Time complexity :  O( 4*m*n) 因为每个点最多判断4次，上下左右    <br>



最简单的方法是DFS mark  <br><br>


// 算法 ： BFS遍历二维矩阵，如果找到1，则BFS把周围的1全部变成0  <br>
// BFS技巧 ； 用一维坐标做queue里元素, 因为找到一个1，则把它标记成0，所以BFS不会往回走，所以不会重复，这里标记起到了set的作用。<br>
1.   <br>





</div>




</body>
