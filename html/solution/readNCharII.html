<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>

public class Solution extends Reader4 {


     //  假设是 0. buf memory is preallocated.
               1. buf每次传进去的都从index 0开始写，不需要maintain bufIndex;(Example 1, example 2 已经讲清楚了)
     //        2. 返回的是每个read() 读的个数，而不是总的读的个数.(Example 1 and Example2 already make this clear)
     //        3. 这个逻辑很不好写
     
        
     char[] buf4 = new char[4];
     int buf4Index = 0;
     int buf4Size = 0; 
     
 
     public int read(char[] buf, int n) {
         
         int count = 0;
         
         while(count < n ){
             
             if ( buf4Index < buf4Size){
                 while ( count < n && buf4Index < buf4Size ){
                     buf[count] = buf4[buf4Index];
                     count++;
                     buf4Index++;
                 }
             }else{
             
                 buf4Size = read4(buf4);
                 buf4Index = 0;
                 if ( buf4Size == 0) return count;
             }
         }
        
         return count;
     }
 }

先从buf读, 在从文件读. 这种写法很简单,但是面试的时候很难想起来,太多的corner case. 这个逻辑写的没有Bug很不容易

Clarification: read() 每次调用后buf指针的位置不用存,since it returns to different buf memory.


</code></pre>
</body>
