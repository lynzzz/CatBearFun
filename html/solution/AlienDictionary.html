<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>



    public String alienOrder(String[] words) {
        
        //Topological sorting
        
        HashMap<Character, Integer> inDegree = new HashMap<>();  // char->count
        HashMap<Character, HashSet<Character>> m = new HashMap<>();  // char->List<char>
            
            
        for(String word : words){
            for( char c : word.toCharArray()){
                inDegree.put(c, 0);
                m.putIfAbsent(c, new HashSet<Character>());
            }
        }
        
        for(int i=0; i<words.length-1; i++){
            String str1 = words[i];
            String str2 = words[i+1];
            
            int min = Math.min(str1.length(), str2.length());
            for(int j=0; j<min; j++){
                char c1 = str1.charAt(j);
                char c2 = str2.charAt(j);
                if ( c1 != c2 && !m.get(c1).contains(c2)){  //不要加重复边进去，进度和图会反复计算）
                    inDegree.put(c2, inDegree.get(c2) + 1);
                    m.get(c1).add(c2);
                    break;
                }
            }
        }
        
        Queue<Character> q = new LinkedList<>();
        
        for(char key : inDegree.keySet()){
            if ( inDegree.get(key) == 0){
                q.add(key);
            }
        }
        
        StringBuilder sb = new StringBuilder();
        
        while(!q.isEmpty()){
            char c = q.poll();
            sb.append(c);
            
            for(char neighbor : m.get(c)){
                inDegree.put(neighbor, inDegree.get(neighbor)-1);
                if ( inDegree.get(neighbor) == 0){
                    q.add(neighbor);
                }
            }
        }
        
        if ( sb.length() != inDegree.size()) return "";
        
        return sb.toString();
        
        // "abc" "ab" 过不了, 这个不是valid input,和题的描述不符合，因为题目保证了 sorted lexicographically
    }

Topological sorting(有重复边)


处理方法：
1.图用 HashMap&lt;char, HashSet&lt;Char>> graph, 这样好检查node是否存在于下一层， 

一类的题目：
course schedule,
course scheduleII


</code></pre>


</div>




</body>
