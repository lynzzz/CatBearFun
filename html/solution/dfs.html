<html>

<body>
DFS subset 模版<br>

适用题目 ： 得到一个整形数组或者字符串的所有分割方法， 结果的顺序和输入是一样的。  例子 { 1， 2， 3}  =>    { {1} {2,3} , {1,2} {3}, {1,2,3} } <br>

输入 ： 大容器， 小容器， 输入， 往前控制符pos<br>

模版 ：<br>

<pre><code>
public void dfs( ArrayList&lt;ArrayList&lt;Integer&gt;> results, ArrayList&lt;Integer> result, int[] nums, int pos){
        
        //  if condition
		if ( pos == nums.length()){
            results.add( new ArrayList&lt;Integer&gt;(result) );       // line c
            return;
		}
        
        
        for( int i = pos; i&lt;nums.length; i++){                // line a
            result.add(nums[i]);
            dfs(results, result, nums, i+1);                     // line b
            result.remove(result.size()-1);
        }
}
</code></pre>

需要注意的地方 ：  <br>
a. Line a, 每一层是从往前控制符pos开始  <br>
b. Line b, 下一层是 i+1, 因为在回溯的过程中i会变，pos不会变，这个 i+1严格控制了不会往回走  <br>
c. Line c, 大容器加入小容器时需要new, 也就是照相，不然小容器内容最终将被清空，得到空的大容器。<br><br>


Coding Questions :<br><br>

Integer array :<br>
     <li><a href="subset.html">Subset</a> <a href="http://www.lintcode.com/en/problem/subsets/">Q</a>  </li>  
	 <li><a href="subsets-ii.html">Subset-ii</a> <a href="http://www.lintcode.com/en/problem/subsets-ii/">Q</a></li>
	 <li><a href="combinations.html">Combinations</a> <a href="http://www.lintcode.com/en/problem/combinations/">Q</a></li>
	 <li><a href="combinationsum.html">Combination Sum</a> <a href="http://www.lintcode.com/en/problem/combination-sum/">Q</a></li>
	 

String<br>
<li><a href="palindrom partition.html">Palindrom Partition</a> <a href="http://www.lintcode.com/en/problem/palindrome-partitioning/#">Q</a></li>
<li><a href="FindMissingNumber-ii.html">FindMissingNumber-ii</a> <a href="http://www.lintcode.com/en/problem/find-the-missing-number-ii/"> Q</a></li>
<li><a href="restoreIPAdress.html">Restore IP Address</a> <a href="http://www.lintcode.com/en/problem/restore-ip-addresses/">Q</a></li>
<li><a href="wordBreak.html">Word Break Lintcode过不了大数据</a> <a href="http://www.lintcode.com/en/problem/find-the-missing-number-ii/"> Q</a></li>

Binary Tree<br>
<li><a href="HouseRubberIII.html">House rubber III</a> <a href="http://www.lintcode.com/en/problem/house-robber-iii/">Q</a></li>



<br><br>
DFS permutation 模版<br>
适用题目 ： 得到一个整形数组的全排列  例子 输入：{ 1， 2， 3}  输出：{1，2，3} {1，3，2} { 2，1，3} {2，3，1} { 3，1， 2} { 3， 2， 1}<br>
既是下一层的元素可以走到上一层元素的左边去,下面的例子第三层元素在第二层元素左边<br>

*1  2    3   <br>
1   2   *3   <br>
1   *2   3   <br>

输入 ： 大容器， 小容器， HashSet装位置去重<br>
模版 ：<br>

<pre><code>
    public void dfs( List&lt;List&lt;Integer&gt;&gt; results, ArrayList<Integer> result, HashSet<Integer> set, int[] nums ){
        
        if ( result.size() == nums.length ){
            results.add( new ArrayList<Integer>(result) );
            return;
        }
        
        for( int i=0; i&lt;nums.length; i++){
            
            if ( set.contains(i) ){
                continue;
            }
            
            set.add(i);
            result.add(nums[i]);
            dfs(results, result, set, nums);
            result.remove(result.size() - 1);
            set.remove(i);
        }
    }
</code></pre>

Coding Questions :<br><br>

Integer array :<br>
     <li><a href="http://www.lintcode.com/en/problem/permutations/#">permutations</a></li> 
     <li><a href="http://www.lintcode.com/en/problem/permutations-ii/#">permutations</a></li> 
     <br>
     此题目较特殊： permutation模版变种<br>
     下一层可以在上一层左边。 但是每层的元素都不一样，所以不可能出现重复，所以不用hashset去重， 传层次控制符，唯一作用是走到下一层，不去重<br>
     <li><a href="http://www.lintcode.com/en/problem/letter-combinations-of-a-phone-number/">Letter Combinations of a Phone Number</a></li> 

</body>



</html>

