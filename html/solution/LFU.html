<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>

you need maintain 4 data structure.

1. vals : key -> val
2. counts : key -> count 
3. lists :  count -> list of key    背诵 这里的数据结构是 linkedhashset, which is sorted hashset. 
   remove O(1). HashSet 
   Need to maintain order: ordered HashSet  // 

   when frequency counts are the same, it becomes least recent used cache (LRU), when evict, it starts from the head
   interator().next() 从头开始访问


4. int mincountCount : 当前最小的count



class LFUCache {
    
   HashMap&lt;Integer, Integer> vals = new HashMap&lt;>();      // key -> value
   HashMap&lt;Integer, Integer> counts = new HashMap&lt;>();    // key -> count
   
   HashMap&lt;Integer, LinkedHashSe&lt;Integer>> lists = new HashMap&lt;>();  // count->list<key>
   
   int mincount = -1;   // mincount;
   
   int cap = 0;


   public LFUCache(int capacity) {
       cap = capacity;
       
   }
   
   public int get(int key) {                     
      // key doesn't exist
      if ( !vals.containsKey(key)) return -1;
      
      // update counts
      int oldCount = counts.get(key);
      counts.put(key, oldCount + 1);
      
      // update lists
      lists.get(oldCount).remove(key);              // remove in O(1) time
      
      // update mincount
      if ( oldCount == mincount && lists.get(oldCount).size() == 0){
          mincount++;
      }
      
      lists.putIfAbsent(oldCount+1, new LinkedHashSet<Integer>());
      lists.get(oldCount+1).add(key);
      
      return vals.get(key);
   }
   
   public void put(int key, int value) {       
       if ( cap &lt;= 0) return;
       
       // key exists
       if ( vals.containsKey(key)){
           vals.put(key, value);
           get(key);                           
           return;
       }else{
         // exceed size, eviction
         if ( vals.size() == cap){
            int evictKey = lists.get(mincount).iterator().next();    // maintain order ordered HashSet
            lists.get(mincount).remove(evictKey);
            counts.remove(evictKey);
            vals.remove(evictKey);
         }
         
         vals.put(key, value);
         counts.put(key, 1);
         lists.putIfAbsent(1, new LinkedHashSet&lt;>());
         lists.get(1).add(key);
         mincount = 1;
      }
   }
}


</code></pre>
</body>
