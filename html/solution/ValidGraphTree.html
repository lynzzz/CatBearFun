<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>



<pre><code>
Solution I : Union Find: 时间复杂 O(e)

class Solution {

    public boolean validTree(int n, int[][] edges) {

        UF uf = new UF(n);
        for( int[] edge : edges){
            if (!uf.union(edge[0], edge[1])){  //找环
                return false;
            }
        }
        return uf.count == 1;    //分类
    }

    class UF{
        int count = 0;
        int[] parent;
        UF(int n){
            count = n;
            parent = new int[n];
            for( int i=0; i&lt;n; i++){
                 parent[i] = i;
            }
        }

        int find( int n){
            if(parent[n] == n) return n;

            return find(parent[n]);
        }

        boolean union(int n1, int n2){
            int p1 = find(n1);
            int p2 = find(n2);

            if( p1 == p2) return false;  //这里的逻辑是如果这两个点已经划分到一类了，说明可以联通了，这时此条边一定是多余的
            parent[p1] = p2;
            count--;
            return true;
        }
    }
}
</code></pre>


<pre><code>
  Solution II : BFS 时间复杂： O(V+E)
 public boolean validTree(int n, int[][] edges) {
        // What is valid tree?
        // 1. no circle
        // 2. no isolated node

        class Solution {
            public boolean validTree(int n, int[][] edges) {
                HashMap&lt;Integer, HashSet&lt;Integer>> graph = new HashMap&lt;>();

                for(int i=0; i&lt;n; i++){
                    graph.put(i, new HashSet&lt;>());
                }

                for(int[] edge : edges){
                    int from = edge[0];
                    int to = edge[1];
                    graph.get(from).add(to);
                    graph.get(to).add(from);
                }

                Queue&lt;Integer> q = new LinkedList&lt;>();
                HashSet&lt;Integer> set = new HashSet&lt;>();

                q.add(0);
                set.add(0);

                List&lt;Integer> ret = new ArrayList&lt;>();

                while( !q.isEmpty()){
                    int node = q.poll();
                    ret.add(node);

                    for( int i : graph.get(node)){
                        if ( set.contains(i)){
                            continue;
                        }
                        set.add(i);
                        q.add(i);
                    }
                }

                return ret.size() == n &amp;&amp; edges.length == n-1; ／／ 第一个条件是判断无孤立点，第二个判断无欢
            }
        }
</code></pre>


</body>
