<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>



<pre><code>
Solution I : Union Find

class Solution {

    public boolean validTree(int n, int[][] edges) {

        UF uf = new UF(n);
        for( int[] edge : edges){
            if (!uf.union(edge[0], edge[1])){  //找环
                return false;
            }
        }
        return uf.count == 1;    //分类
    }

    class UF{
        int count = 0;
        int[] parent;
        UF(int n){
            count = n;
            parent = new int[n];
            for( int i=0; i&lt;n; i++){
                 parent[i] = i;
            }
        }

        int find( int n){
            if(parent[n] == n) return n;

            return find(parent[n]);
        }

        boolean union(int n1, int n2){
            int p1 = find(n1);
            int p2 = find(n2);

            if( p1 == p2) return false;
            parent[p1] = p2;
            count--;
            return true;
        }
    }
}
</code></pre>


<pre><code>
  Solution II : BFS
 public boolean validTree(int n, int[][] edges) {
        // What is valid tree?
        // 1. no circle
        // 2. no isolated node
		// 3. undirected edge
		无向，无环，无孤


        // 此题目的结论 n 个点图无环，只能有n-1条路径
        if ( edges.length != n - 1){
            return false;
        }



        HashMap&lt;Integer, List&lt;Integer>> graph = new HashMap&lt;>();

        // Create adjacent list
        // since there are n nodes, labeled from 0 to n-1, 必然有通往这n个点的路径，可以创造adjacent list.

        for( int i=0; i&lt;n; i++){
            graph.put(i, new ArrayList<Integer>() );
        }

        for( int i=0; i&lt;edges.length; i++){
            int from = edges[i][0];
            int to = edges[i][1];
            graph.get(from).add(to);
            graph.get(to).add(from);
        }


        // BFS, 遍历图，保证无isolated点
        Queue&lt;Integer> q = new LinkedList&lt;>();
        HashSet&lt;Integer> visited = new HashSet&lt;>();

        q.add(0);
        visited.add(0);

        while( !q.isEmpty() ){

            int node = q.poll();

            for( int i : graph.get(node)){
                if ( visited.contains(i) )
				{
				    continue;
				}
                    q.add(i);
                    visited.add(i);
            }
        }

        return visited.size() == n;

    }
}
</code></pre>


</body>
