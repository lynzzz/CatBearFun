<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>
<pre><code>


    class Solution {
        public List<List<Integer>> combinationSum2(int[] candidates, int target) {
            Arrays.sort(candidates);   // sort 和下面的visited连用才能保证没有重复.
            
            List<List<Integer>> rets = new ArrayList<>();
            dfs(rets, new ArrayList<Integer>(), new boolean[candidates.length], candidates, target, 0);
            
            return rets;
            
        }
        
        void dfs(List<List<Integer>> rets, List<Integer> ret,
                 boolean[] visited,
                int[] candidates, int target, int pos){
            
            if ( target < 0) return;
            
            if ( target == 0){
                rets.add(new ArrayList<Integer>(ret));
                return;
            }
            
            for( int i=pos; i<candidates.length; i++){
                if ( i>=1 && candidates[i] == candidates[i-1] &&
                   !visited[i-1]) continue;
                
                
                visited[i] = true;
                ret.add(candidates[i]);
                dfs(rets, ret, visited, candidates , target - candidates[i], i+1);
                ret.remove(ret.size()-1);
                visited[i] = false;
            }
            
        }
    }

Time O(n* 2^(n))

</code></pre>


<div class="comment">
Note: 答案不回溯，仍然是向前搜索，subset模扳。<br>

1. 与subset模扳一致，每个位置只能取一次，所以是dfs(, , , i+1)   注意combination sum 可以一个位置多次取，所以是 dfs(, , , i);<br>
2. 输入里的重复元素处理，用boolean array和， subset II处理方法完全一致。  见标注[1]<br>



</div>



</body>
</html>