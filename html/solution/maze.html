<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
DFS:

class Solution {

    boolean ans = false;

    public boolean hasPath(int[][] maze, int[] start, int[] destination) {

        boolean[][] visited = new boolean[maze.length][maze[0].length];
        int[][] dirs = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};

        dfs(start[0], start[1], destination, maze, visited, dirs);
        return ans;
    }

    void dfs(int x, int y, int[] destination, int[][] maze, boolean[][] visited, int[][] dirs){
        int row = maze.length;
        int col = maze[0].length;

        if (  visited[x][y]){
            return;
        }

        if ( x == destination[0] &amp;&amp; y == destination[1]){
            ans = true;
            return;
        }

        visited[x][y] = true;

        for(int[] dir : dirs){
            int i = x + dir[0];
            int j = y + dir[1];

            while( i>=0 &amp;&amp; i&l;trow &amp;&amp; j>=0 &amp;&amp; j&lt;col &amp;&amp; maze[i][j] == 0 ){
                i = i + dir[0];
                j = j + dir[1];
            }

            i = i- dir[0];
            j = j - dir[1];

            if ( !visited[i][j]){
                dfs(i, j, destination, maze, visited, dirs);
            }
        }
    }
}


BFS:

class Solution {

    public boolean hasPath(int[][] maze, int[] start, int[] destination) {

        Queue&lt;int[]> q = new LinkedList&lt;>();
        int row = maze.length;
        int col = maze[0].length;

        boolean[][] visited = new boolean[row][col];
        int[][] dirs = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };

        q.add(new int[] {start[0], start[1]});
        visited[start[0]][start[1]] = true;

        while( !q.isEmpty()){
            int[] n = q.poll();
            if ( n[0] == destination[0] &amp;&amp; n[1] == destination[1]){
                return true;
            }

            for( int[] dir : dirs){
                int x = n[0] + dir[0];
                int y = n[1] + dir[1];

                while( x>=0 &amp;&amp; x&lt;row &amp;&amp; y>=0 &amp;&amp; y&lt;col &amp;&amp;maze[x][y] == 0){
                    x = x + dir[0];
                    y = y + dir[1];
                }

                x = x-dir[0];
                y = y-dir[1];

                if ( !visited[x][y]){
                    visited[x][y] = true;
                    q.add(new int[]{x, y});
                }
            }
        }

        return false;
    }
}
</code></pre>






<div class="comment">

Time complexity :    O(mn)  <br>
Space complexity :   O(mn)  <br>



</div>




</body>
