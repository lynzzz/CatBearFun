

<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>

<li><a href="numberOfIslands.html">Number of islands</a> <a href=https://leetcode.com/problems/number-of-islands/description/>Q</a></li>
<li><a href="maxAreaOfIslands.html">Max area of islands</a> <a href=https://leetcode.com/problems/max-area-of-island/description/>Q</a></li>
<li><a href="floodFill.html">flood fill</a> <a href=https://leetcode.com/problems/flood-fill/description/>Q</a></li>
<li><a href="SurroundedRegions.html"></a> <a href=http://www.lintcode.com/en/problem/surrounded-regions/>Q</a></li>
<li><a href=https://leetcode.com/problems/word-search//>word search in a 2D array</a></li>



<pre><code>

棋盘类DFS模板

void dfs( start, matrix)
{

  1. 递归的三个结束条件判断 （ 过界，撞墙，访问过）

	2. 递归达到某种要求（走到某点， 返回 ）

	3. 附加数据结构标记为访问过，某些情况下可以直接mark图，不需要在还原。如number of islands.

	4. 找到下一层的所有坐标，分别做DFS broadcast

  5. （把附加数据结构标记还原）.
}



Google 面试题目： 能不能从一点走到另外一点，
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。


BFS解法

void BFS(int x, int y, int m, int n){

     Queue&lt;int[]> q = new LinkedList&lt;>();
	 HashSet&lt;int[]> set = new HashSet&lt;>();


	 q.add(new int[]{}(x,y));
	 set.add(new int[][{x,y});

	 while( ！q.isEmpty（））{
	     int[] node = q.poll();

		 if （ node[0] == m, &amp;&amp; node[1]  == n ){
		      return true;
		 }

		 if ( 2*node[0] <= m &amp;&amp; node[1] <= n &amp;&amp; 判断 (2*n[0], n[1])未访问过 ){
		     q.add(new Node(2*n[0], y);
		     set.add(new Node(2*n[0], y));
		}

		 if ( n[0] <= m &amp;&amp; 2n[1]<= m &amp;&amp; 判断 （n[0], 2*n[1])未被访问过 ){
		     q.add(Node(n[0], 2*n[1](;
		     set.add(Node(n[0], 2*n[1]);
		 }
	 }

	 return false;
}

DFS 解法
boolean ans = false;

void DFS(int x, int y, int m, int n， boolean[][] visited){

	if ( x > m || y > n || visited[x][y] ){
	    return;
	}

    if ( x == m &amp;&amp; y == n ){
	    ans = true;
		return;
	}

    visited[x][y] = true;

    DFS(2x, y, m, n);
	  DFS(x, 2y, m, n);

    visited[x][y] = false;
}


</code></pre>







</div>




</body>
