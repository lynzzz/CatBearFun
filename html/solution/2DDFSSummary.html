

<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>

<li><a href="numberOfIslands.html">Number of islands</a> <a href=https://leetcode.com/problems/number-of-islands/description/>Q</a></li>
<li><a href="maxAreaOfIslands.html">Max area of islands</a> <a href=https://leetcode.com/problems/max-area-of-island/description/>Q</a></li>
<li><a href="floodFill.html">flood fill</a> <a href=https://leetcode.com/problems/flood-fill/description/>Q</a></li>
<li><a href="SurroundedRegions.html"></a> <a href=http://www.lintcode.com/en/problem/surrounded-regions/>Q</a></li>
<li><a href=https://leetcode.com/problems/word-search//>word search in a 2D array</a></li>



<pre><code>

棋盘类DFS模板

void dfs( start, matrix)
{

  1. 递归的三个结束条件判断 （ 过界，撞墙，访问过）

	2. 递归达到某种要求（走到某点， 返回 ）

	3. 附加数据结构标记为访问过，某些情况下可以直接mark图，不需要在还原。如number of islands.

	4. 找到下一层的所有坐标，分别做DFS broadcast

  5. （把附加数据结构标记还原）.
}



Google 面试题目： 能不能从一点走到另外一点，
在第一象限内一点（x,y）, 每次可以走一步，下一步可以是(x+x, y), 或者（x, y+y）， 求问能否走到一个点（m,n）。注意，x>0, y>0，刚开始认为是四个象限，如果都是正数，不难。没有找出最优解，小姐姐说没关系，她觉得正常人需要一两天才能找出最优解。做完还剩5分钟，小姐姐要我问问题，我太累了，不想问，小姐姐还是觉得我应该问，我只好问了，然后去上厕所。


BFS解法

void BFS(int x, int y, int m, int n){

     Queue&lt;int[]> q = new LinkedList&lt;>();
	 HashSet&lt;String> set = new HashSet&lt;>();


	 q.add(new int[]{}(x,y));
	 set.add(x+" "+y);

	 while( ！q.isEmpty（））{
		 int[] node = q.poll();
		 
		 int newX = node[0];
		 int newY = node[1];

		 if （newX == m, &amp;&amp; newY  == n ){
		      return true;
		 }



		 if ( 2*newX <= m &amp;&amp; newY <= n &amp;&amp; && !set.contains(2*newx + " " + newY) ){
		     q.add(new Node(2*newX, newY);
		     set.add(new Node(2*newX, newY));
		}

		 if ( newX <= m &amp;&amp; 2newY<= m &amp;&amp; && !set.contains(newx + " " + 2*newY) ){
		     q.add(Node(newX, 2*newY(;
		     set.add(Node(newX, 2*newY);
		 }
	 }

	 return false;
}

DFS 解法
boolean ans = false;

void DFS(int x, int y, int m, int n， boolean[][] visited){

	if ( x > m || y > n || visited[x][y] ){
	    return;
	}

    if ( x == m &amp;&amp; y == n ){
	    ans = true;
		return;
	}

    visited[x][y] = true;

    DFS(2x, y, m, n);
	DFS(x, 2y, m, n);
}


</code></pre>







</div>




</body>
