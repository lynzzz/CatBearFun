<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>

  <li><a href="topologicalSorting.html">Topological Sorting</a>  <a href=https://www.lintcode.com/problem/topological-sorting/description>Q</a></li>
  <li><a href="courseschedule.html">course schedule(Topological sorting)</a> <a href="https://leetcode.com/problems/course-schedule/">Q</a>  </li>
  <li><a href="coursescheduleii.html">course schedule II</a> <a href="https://leetcode.com/problems/course-schedule-ii/">Q</a>  </li>
  <li><a href="AlienDictionary.html">Alien dictionary(Topological sorting with duplicate edges)</a> <a href=https://leetcode.com/problems/alien-dictionary/description/>Q</a></li>
  <li><a href="EvaluateDivision.html">Evaluate Division(有向图里能否从一点到另一点，返回权重，DFS)</a> <a href="https://leetcode.com/problems/evaluate-division/description/">Q</a>  </li>
  <li><a href="reconstructitinerray.html">Reconstruct Itinerary(有向图DFS搜索某种路径： 断边法)</a> <a href="https://leetcode.com/problems/reconstruct-itinerary/description/">Q</a>  </li>
  <li><a href="FindEventualSafeStates.html">Find Eventual safe sttes(有向图DFS找环：暴力搜索法， 染色法)</a> <a href=https://leetcode.com/problems/find-eventual-safe-states/description/>Q</a>  </li>
  <li><a href="NetworkDelayTime.html">NetWork Delay(有向图DFS, 求全局权重最优)</a> <a href=https://leetcode.com/problems/network-delay-time/description/>Q</a>  </li>
  <li><a href="MinimalHeightTree.html">Tree Graph（树图剪枝法）</a> <a href="https://leetcode.com/problems/minimum-height-trees/description/">Q</a>  </li>
  <li><a href="ShortestPathwithAlternatingColors.html">Shortest Path with Alternating Colors(有向图边带颜色求最短路径 DFS超时，BFS)</a> <a href=https://leetcode.com/problems/shortest-path-with-alternating-colors/>Q</a></li>




<pre><code>

记住togological sorting以下结论：
用处 ： 有向图层次遍历
注意 ： 1. 必须从进度为0的点出发
       2. 如果图里有环的活，BFS会提前结束不能遍历图里所有的点，可以加一个counter来计数
       3. 不需要HashSet去重



Topological sorting 数据结构
进度表 + 点图 => 进度BFS

进度表  HashMap&lt;Integer, Integer> degree = new HashMap&lt;>();
点图    HashMap&lt;Integer, HashSet&lt;Integer>> = new HashMap&lt;>(); 用HashSet的原因是adjacent list里不应该有重复的边，建图的时候要注意去掉重复的边，不然进度表和图都不对, 如果注明了没有重复的边，可以用List&lt;Integer> 代替



构造进度表和图
1. 先初始化图和进度表，这样就保证了每个点都在图和进度表里，这样写的好处是，构造图的时候不用考虑点存不存在图中，做BFS时候也不用考虑点是否存在于图中。

        for( int i=0; i&lt;numCourses;i++){
            degree.put(i, 0);
            graph.put(i, new HashSet&lt;>());
        }

2.  构造图和进度表
        for( int[] e : prerequisites){

            int from = e[1];
            int to = e[0];
            graph.get(from).add(to);
            degree.put(to, degree.get(to) + 1);
        }


进度BFS实现

step 1 :找到进度为0的点

Queue&lt;Integer> q = new LinkedList&lt;>();
for( int key : degree.keySet()){
    if ( degree.get(key) == 0 ){
	    q.add(key);
	}
}

Step 2: 进度控制BFS

int count = 0
while( !q.isEmpty() ){
    int n = q.poll();
	count++;

    for( int neighbor : graph.get(n) ){
        degree.put(neighbor, degree.get(nbeighbor)-1);
        if ( degree.get(neighbor) == 0 ){
            q.add(neighbor);
        }
    }
}


step 3

return count == degree.size();
判断遍历的个数和顶点数是否一致，不一致就有环。


//代码的注意

1. 需要注意的是进度BFS不用HashSet去重，因为是从进度为0的点出发，逐步加入进度为0的点， 所以不会往会走，所以不会有重复，所以不需要去重。





</code></pre>





</body>
