
<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
Solution I: Union Find

  class Solution {
      public int countComponents(int n, int[][] edges) {

          UF uf = new UF(n);
          for( int[] edge: edges){
              uf.union(edge[0], edge[1]);
          }

          return uf.count;
      }

      class UF{
          int parent[];
          int count;

          UF(int count){
              this.count = count;
              parent = new int[count];
              for(int i=0; i&lt;count; i++){
                  parent[i] = i;
              }
          }

          int find(int n){
              if ( parent[n] == n){
                  return n;
              }
              return find(parent[n]);
          }

          void union(int n1, int n2){
              int root1 = find(n1);
              int root2 = find(n2);

              if ( root1 == root2) return;

              parent[root1] = root2;

              count--;
          }
      }
  }

  Time:   O(e) with rank.
  Space : O(e)


  Solution II: BFS
  class Solution {
    public int countComponents(int n, int[][] edges) {

        Map&lt;Integer, List&lt;Integer>> m = new HashMap&lt;>();
        for( int i=0; i&lt;n ;i++){
            m.put(i, new ArrayList&lt;>());
        }

        for(int[] edge : edges){
            m.get(edge[0]).add(edge[1]);
            m.get(edge[1]).add(edge[0]);
        }

        int count = 0;
        Queue&lt;Integer> q = new LinkedList&lt;>();
        Set&lt;Integer> set = new HashSet&lt;>();

        for( int i=0; i&lt;n ;i++){
            if (set.contains(i)){
                continue;
            }

            q.add(i);
            set.add(i);

            while( !q.isEmpty()){
                int node  = q.poll();

                for( int neighbor : m.get(node)){
                    if ( set.contains(neighbor)){
                        continue;
                    }

                    q.add(neighbor);
                    set.add(neighbor);
                }
            }
            count++;
        }

        return count;
    }
}

Time: O(n + e)
Space:O(n + e)

</code></pre>







</body>
