<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>
Goal:
Senior + compsentation
online service team using C++


Google(very few headcount/downlevel/Lowball/Need compete offer)





design:
第二题design rate limiter

设计系统允许用户rate歌曲，并检索top rated歌曲。读写分离设计。
题目大概如此，给的比较模糊，所以整个过程会跟对方确认各种细节。基本思路是确认功能集，估算资源和规模，讨论high level框架，deep dive存储层，分析如何scale和容错，讨论过程中会提到一些开源系统，解释为何选用，以及一些tradeoffs。这轮是拿coderpad做的，写设计文档..


现场SD:   设计一个计数器服务，记录所有对外提供的服务的各种活动








                                          FB:
coding: 543(ok), 42(ok), 56(ok), 297(ok), 88(ok), 23(ok), 1026(ok), 773(ok), 84(ok)
109(ok)， 938(ok), 328(ok), 896(ok), 54(0k), 157(ok), 158(ok), 20(ok), 22(ok), 301(ok), 1249(ok), 472(ok), 339(ok), 973(ok), 1197(ok), 215, 785, 1249(ok), 1428, 621(ok), 560(ok), 129(ok), 238(ok)
416(ok), 435(ok), 236(ok), (858), 1047(ok), 211(ok), 10(ok), 191(ok), 125(ok), 78(ok)， 339, 71变体(ok), 239变体(ok), 498 变体(ok) 单向右上(每一层都翻转 ok)
1123(ok), 47(ok), 154(ok), 1275(n*n O(1) ok) 

925


                                          FB: Desgin:

Design 1:

But based on what I saw, I believe it is the web crawler problem with a large number of nodes.
As I can think, there are two ways.
1. centralized queue to distribute the workload to each node.  you have to ask the interviewer to clarify if this makes sense.
2. peer to peer network with something like NOsql/sql, depends on how strictly you allow the crawling the same url. to provide fault tolerance, I believe that you will have to allocate multiple nodes and use consistent hashing for allocating urls. when there is node failure or node addition, zookeeper like service needs to synch the new DHT/configuration to each node, so each node knows where they should send the mined urls that are not supposed to handle locally.

Design这题从之前的面经来看，大概率用message queue是不行的，也有的被要求继续design message queue。我看到的几个过经都是用的P2P DHT(Distributed hashtable)，讲一下consistent hashing，然后讲一下DHT里面比较popular的方案，Chord，KAD之类的。总之感觉几个坑题都跟P2P有关，然后Grokking没怎么讲到P2P的案例，需要自己上网找材料。



Design 2: Type Ahead


Design 3 : System Design. 先玩游戏， 然后返回leaderboard 信息包括global ranking, global top 10，friends ranking，自己的ranking 前面十个 后个十个之类的
           
           大家玩完游戏后往一个统计分数service发写请求,送分数, 然后一张DB表存 global ranking
           在用一张表存自己的前10后10.

           Requirement + capacity.

           Global ranking table: 
           User Id     pk 
           score       int 
           user Name   string
           rank        int 


           前10后10table:
           user id                 pk 
           user name               string 
           Top10Bottom10 user id   fk

           Friendship table:
           id           int  pk 
           from_user    int 
           to_user      int


           另外一个service接受读请求, 
           read global table to global ranking   (cache)  
           read global table top 10 (cache)
           从Friendship DB读好友, 从global table查分数, 排序,返回给User.
           从前10后10 table读自己的前10后10.


           partition using user id.



                                         FB: BQ
讲了最自豪的project
工作中做过什么错误的决定
onflicts with colleagues
negative feedback from manager
deal with deadlines

bq挑刺的地方就是一直在challenge你的答案  一定要一些经验  比如跟别人意见不同，结果你是错的  同时还要说跟别人意见不同，结果你是对的  要详细描述这个push back的过程（我这个部分讲了2分钟，他觉得不够戏剧化，不够detail）  还有要说自己曾经失败的经验  说了一个 他觉得不算 要真正失败的经验  全程就感觉是鸡同鸭讲  还有就是bq就是要很会讲故事 可能我讲故事能力太弱  
















                                          Twitter Codin
Coding:
380, 57

T1
Coding: 380 的延伸，就是除了原题的要求，还要求getLast也是O(1)。所以要用map+doubly linked list来找getlast，map+list来找getrandom。写完了还要写unit tests，refactor code，还问有更多时间还可以做什么，比如加更多的api啊，注释啊，之类的

虑到多线程的各个corner case。




T2 

电面题是给一堆record 有的信息是 user, epoc_timestamp, activity
然后有个叫user active minute的东西 就是如果用户在这分钟干过任何事情就算active了
按照用户活跃的时间分bracket 比如算一天的 bracket是100分钟 那就返还一个list, 分别是UAM为0-99，100-199 ... 1400-1440 的用户
函数Input就是records和bracket size, 假设time span一个月
题目并不难 主要就是一些data structure的选择和细节 比如dedup timestamp  问清use case

Assume the log is sorted by epoc_timestamp:

convert epoch_timestamp to per minute calandar time in minute bucket. => 16304332543 => "09/24/2020 05:47"

HashMap<User, HashSet<String>>
for( record: records){
   string perminuteTimeBucket = helper(epoch_timestamp);
   if ( !m.containsKey(user)){
      HashSet<String> set = new HashSet<>();
      set.add(perminuteTimeBucket);
      m.put(user, set);
   }else{
      if ( !m.get(user).containsKey(perminuteTimeBucket)){
         m.get(user).add(perminuteTimeBucket);
      }
   }
}

List<List<String>> ret;

for(Map.Entry<User,HashSet<STring>) e : m.entrySet()){
   int count = e.getValue().size();

   if ( count > 0 && count < 99){
       ret.get(0).add(e.getKey())
   }

   ///////
}





一上来差点就问了和电面一样的题 看来他们家是有题库的 但实诚如LZ说了做过 于是换成一道类似李口 勿溜  56
略有不同 Input 一个已有meeting的list 然后给你个新的meeting merge进那个list就行(57)
一大早脑子有点短路没想到特别好的办法 但三四个if else也搞定了


给一个二维board of characters 和一个list of words, 在那个board上可以任意起点8个方向任意走返还所有存在的words
先说了思路造个trie 然后搞bfs 三哥们表示欧凯
主逻辑写的时候假设有这么个trie 然鹅LZ准备的时候根本没写过 心里很慌因为到时还是要写的。。
但其实边写边解释边讨论花掉不少时间 最后implement trie的时候其实也大概猜出trie该怎么



T3
题目还挺简单的，实现一个EventCounter，有如下API
void record(string eventName, long timeStamp);
vector<long> getEventCountPerMinute(string eventName, long start, long end);
第二个API要求比较奇怪，她要求返回每分钟的count，假如start是9:00，end是9:02，返回的数组是[2,1,0]，其中0表示那个时刻没有event。
我选择了用HashMap存储，直接就是计数器。编译之后自己写一些test case测试一下。然后分析了一下复杂度。
关于timeStamp本来是epoch time的，应该要转化成每个分钟，但是她说这部分在面试过程就先不考虑了，假设提供的timeStamp都是整分钟的时刻。




Solution:

HashMap<Event, HashMap<timestamp, count>>
Timestamp 在两个API都要换成per minute来存。


Follow up 1：如果数据量特别大，内存放不下怎
use LRU cache and save everything on disk. Search memory first and then hard disk.







T4
对一段SMS message，我们的协议每次只能发送不超过60个字节。要求实现一个算法，
将给定的string break成长度不超过60个字节的片段。要求：1. 每个词(通过whitespace split的词)不能被break，假如有一个词比如说compensation，不可以compens在前一个片段，ation在后一个片段，并且不用担心单个词长度就已经超标的情况；2. 每个片段后面要跟着一个suffix，







                                          OA : 24小时做完

1，k-difference distinct number 力扣532 简化版，数组里没有重复数字。
2  4，get set got 类似力扣40, 简化版。只要求判断是否能找到组合 使之等于 target
找有多少个回文的substring
palindrome
3. Restocking the Warehouse
4. Twitter New Office Design

othenticating token 
https://leetcode.com/discuss/interview-question/378237/Twitter-or-OA-2019-or-Authentication-Tokens

Partitioning array
https://leetcode.com/discuss/interview-question/375262/Twitter-or-OA-2019-or-Partitioning-array


第一题 authentication token
第二题 buying show ticket
第三题 parking dilemma
第四题 reaching point



注意第二题在大佬的总结里是没有答案的，现场自己做的时候用暴力会超时，后来我在网上找到了答案：
以下内容需要积分高于 95 您已经可以浏览

def waitingTime(tickets, p):
    total_steps = tickets[p]
    first_half = tickets[:p]
    second_half = tickets[p+1:]

    for num in first_half:
        if num < tickets[p]:
            total_steps += num
        else:
            total_steps += tickets[p]

    for num in second_half:
        if num < tickets[p]:
            total_steps += num
        else:
            total_steps += tickets[p] - 1

    return total_steps



桌面有总结pdf








                                          Twitter Design:
rate limiter.



或许可以用list存（当前时间，当前点赞数）
对于每一个时间，用二分查找找出五分钟前的点赞数，再用当前点赞数减去 (不好写)

或者用treemap也可以吧( where key is time, value is count).  (好写些)



m.floorEntry(current Time).getValue() will give you 当前点赞数
m.floorKey(curTime - 5).getValue() will you 5 分钟前的点赞数. 
两个想减












                                      Google interview 


1）优化Web服务器实现从本地文件系统提供静态内容

2） 在围棋游戏中，如果你的周围全是棋子，将被捕获，如果你包围了自己，边界将扩大，写一个方法判断一个点是否会被捕获。

3）生成一个井字游戏的地图，包括了全部的状态和下一步的移动。规则（按序走）：如果中间为空，则赢。如果可以，击败对手，放入一个随机的地方。

4）给出了一个已知宽，高和支持的最大最小字体的屏幕，确定一个给定的字符串能显示的最大字体，单词和字符


LC 736  too hard. lisp expression





4.27 电面 巴斯斯，优化到O(1)空间复杂度  844 ?



电面: LC 流要移变形 (顺序不变) (ok 9/5)  611 ?

现场一:   尔伞巴, 咬斯巴 238(ok 9/3)   148(9/3 ok)

现场二:   无流岭, 腰尔救 560(ok 9/2) , (129 ok 9/2)

现场三(training): 腰腰救妻, 尔义伍 ( 1197)(ok 9/2)   215( priority queue ok 9/2)

现场SD:   设计一个计数器服务，记录所有对外提供的服务的各种活动
BQ:  经典题 proud project, failure experience, obstacles, feedback from previous managers


</code></pre>
</body>
