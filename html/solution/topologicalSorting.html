<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
public class Solution {
    /**
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */    
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        // write your code here
        ArrayList<DirectedGraphNode> answer = new ArrayList<>();


        // construct indegree table
        HashMap<DirectedGraphNode, Integer> m = new HashMap<>();       
            for( DirectedGraphNode neighbor : node.neighbors){ 
                if ( !m.containsKey(neighbor) )
                    m.put(neighbor, 1 );
                else
                    m.put(neighbor, m.get(neighbor)+1);
            }
        }
        
        // find the node not in indegree map, which are start points
        Queue<DirectedGraphNode> q = new LinkedList<>();         
        for( DirectedGraphNode n : graph){
            if ( !m.containsKey(n) ){
                q.add(n);
            }
        }
        

        // BFS + indegree table update
        while( !q.isEmpty() ){
            DirectedGraphNode n = q.poll();
            answer.add(n);
            for( DirectedGraphNode neighbor : n.neighbors){
                m.put(neighbor, m.get(neighbor)-1);     // 可以理解为断开连表
                if ( m.get(neighbor) == 0 ){
                    q.add(neighbor);
                }
            }
        }
        
        return answer;
    }
}


</code></pre>






<div class="comment">
Topological sorting （中文名拓扑排序）: 有向图从入口到出口遍历，有环的点遍历不到。<br>
方法：<br> 
1.构造adjacent list, 构造进度表 <br>
2.进度为0点BFS，更新进度，只有下一个进度为0，才能加入queue,不用set<br>


进度表  + 点图  => BFS

 
</div>




</body>
