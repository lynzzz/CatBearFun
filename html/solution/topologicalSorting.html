<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
  class DirectedGraphNode {
       int label;
       ArrayList&lt;DirectedGraphNode> neighbors;
       DirectedGraphNode(int x) { label = x;}
  };

  public class Solution {

      public ArrayList&lt;DirectedGraphNode> topSort(ArrayList&lt;DirectedGraphNode> graph) {

          HashMap&lt;DirectedGraphNode,Integer> m = new HashMap&lt;>();
          for(DirectedGraphNode node : graph){
              m.put(node, 0);
          }

          for (DirectedGraphNode node : graph) {
             for(DirectedGraphNode neighbor : node.neighbors){
                 m.put(neighbor, m.get(neighbor) + 1);
             }
          }

          Queue&lt;DirectedGraphNode> q = new LinkedList&lt;>();
          ArrayList< DirectedGraphNode> ret = new ArrayList&lt;>();

          for (Map.Entry&lt;DirectedGraphNode,Integer> e : m.entrySet()) {
              if (e.getValue() == 0) {
                  q.add(e.getKey());
              }
          }

          while (!q.isEmpty()) {
              DirectedGraphNode n = q.poll();
              ret.add(n);

              for (DirectedGraphNode neighbor : n.neighbors) {
                  m.put(neighbor, m.get(neighbor) - 1);
                  if (m.get(neighbor) == 0) {
                      q.add(neighbor);
                  }
              }
          }

          return ret;
      }
  }



</code></pre>






<div class="comment">
Topological sorting （中文名拓扑排序）: 有向图从入口到出口遍历，有环的点遍历不到。<br>
方法：<br>
1.构造进度表 <br>
2.进度为0点BFS，更新进度，只有下一个进度为0，才能加入queue, 不用set<br>

Note:<br>
m.put(node, m.get(node)++) won't work, since Integer is immutable, cannot increment<br>
m.put(node, m.get(node)+1) works, auto boxing and auto unboxing

m.get(node) + 1 won't work, since the old reference stays unchanged. 

</div>




</body>
