<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>


Solution I : DFS brute force 没有返回值: 这种写法无法纪录值做优化(DFS + memorization)
class Solution {
    int module = (int)Math.pow(10, 9) + 7;
    int total = 0;
    int step;
    int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};

    public int knightDialer(int N) {
        
        int total = 0;
        step = N;

        for( int i=0; i<=9; i++){
            dfs( 1, i));
        }
        return total;
    }

    void dfs(int curStep, int curPos  ){
        if ( curStep == step){
            total++;
            return;
        }

        int total = 0;
        for(int i : dict[curPos]){
            dfs(curStep+1, i));
        }
    }
}

Solution II : DFS brute force 有返回值

DFS top down:
第一步在哪里，第二部走到哪里，。。。。。 第n步走到哪里。


class Solution {
    int module = (int)Math.pow(10, 9) + 7;
    int step;
    int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};


    public int knightDialer(int N) {
        int total = 0;
        step = N;

        for( int i=0; i<=9; i++){
            total = (total + dfs(1, i))%module;
        }
        return total;
    }

    int dfs(int curStep, int curPos  ){
        if ( curStep == N){
            return 1;
        }

        int total = 0;
        for(int i : dict[curPos]){
            total = (total + dfs(curStep+1, i))%module;
        }
        return total;
    }
}

Solution III: DFS + memorization

class Solution {
    int module = (int)Math.pow(10, 9) + 7;
    int step;
    int[][] dict = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};
    Integer[][] mem;


    public int knightDialer(int N) {

        Integer[][] mem = new Integer[N][10];  // N步, [0, N-1], 第一步为0, 最后一步为N-1;


        int total = 0;
        step = N;

        for( int i=0; i<=9; i++){
            total = (total + dfs(0, i))%module;           //  第一步为0
        }

        return total;
    }

    int dfs(int curStep, int curPos ){

        if ( curStep == step-1){                          // 最后一步N-1
            return 1;
        }

        if ( mem[curStep][curPos] != null){
            return mem[curStep][curPos];
        }

        int total = 0;
        for(int i : dict[curPos]){
            total = (total + dfs(curStep+1, i))%module;
        }
        mem[curStep][curPos] = total;
        return total;
    }
}

</code></pre>




<div class="comment">
Time complexity :  O(N)    <br>
Space complexity : O(N*10) = O(n)    <br>

0. 跳棋模型： 给定步数和走法限制，求多少种跳法
1. DFS带两参数，一个是当前步数(CurStep)，一个是当前值(CurValue)。 CurStep 是为了找递归结束条件，CurVal是为了找下一层的值
2. 这种两个参数的DFS很容易优化成DFS + Memorization，DFS一定要返回值。dp[curStep][curVal]表示某步走到某个位置有几种走法，记录下来，不用重复的算，因为DFS
走到最底层然后开始回溯，往前走一个系数，然后再往下走，所以必然会遇到重复的点。


</div>




</body>
