<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
public class Solution {
    /**
     * @param root the root of binary tree
     * @param target an integer
     * @return all valid paths
     */
    public List<List<Integer>> binaryTreePathSum(TreeNode root, int target) {
        // Write your code here
        
        ArrayList&lt;List&lt;Integer>> ret = new ArrayList<>();
        ArrayList&lt;Integer> result = new ArrayList<>();
        if ( root == null) return ret;

         
        result.add(root.val);
        dfs( ret, result, root, target );
        
        return ret;
        
    }
    
    
    private void dfs( List<List<Integer>> results, List<Integer> result, TreeNode root, int target){
        
        int sum = 0;
        for( int n : result){
            sum = sum + n;
        }
        
        
        // From root node to leaf node means from top to bottom
        if ( sum == target && root.left == null && root.right == null){
            results.add( new ArrayList<Integer>(result) );
            return;
        }
        
        
        if ( root.left != null){
            result.add(root.left.val);
            dfs(results,result, root.left, target);
            result.remove(result.size()-1);
        } 
        
        if ( root.right != null){
            result.add(root.right.val);
            dfs(results, result, root.right, target);
            result.remove(result.size()-1);
        }
    }
}





</code></pre>






<div class="comment">


all possible sulutions -> DFS -> Binary tree Tranversal ->答案在参数中  <br>


此题的技巧，在遍历之前把树顶先加进去，这样左遍历结束的时候可以保留树顶，然后开始右遍历<br>


测试的时候用 1，  1，2，# 测试   <br>

<br>
Last Time completed at : 11/14/2017


</div>




</body>
