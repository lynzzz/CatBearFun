<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
public class Solution {
    /**
     * @param root the root of binary tree
     * @param target an integer
     * @return all valid paths
     */
    public List<List<Integer>> binaryTreePathSum(TreeNode root, int target) {
        // Write your code here
        
        ArrayList<List<Integer>> ret = new ArrayList<>();
        ArrayList<Integer> result = new ArrayList<>();
        if ( root == null) return ret;

         
        result.add(root.val);
        dfs( ret, result, root, target );
        
        return ret;
        
    }
    
    
    private void dfs( List<List<Integer>> results, List<Integer> result, TreeNode root, int target){
        if ( root == null){
            return;
        }
        
        int sum = 0;
        for( int n : result){
            sum = sum + n;
        }
        
        
        // From root node to leaf node means from top to bottom
        if ( sum == target && root.left == null && root.right == null){
            results.add( new ArrayList<Integer>(result) );
            return;
        }
        
        
        if ( root.left != null){
            result.add(root.left.val);
            dfs(results,result, root.left, target);
            result.remove(result.size()-1);
        } 
        
        if ( root.right != null){
            result.add(root.right.val);
            dfs(results, result, root.right, target);
            result.remove(result.size()-1);
        }
    }
}





</code></pre>






<div class="comment">
Time complexity :      <br>
Space complexity :     <br>


Algorithm<br>
all possible sulutions -> DFS 遍历 <br>

1.   <br>




<br>
Note <br>
binary tree遍历模板
// 参数 ： 大容器，小容器<br>
// 递归结束条件， 左右<br>

此题的技巧，在遍历之前把树顶先加进去，这样左遍历结束的时候可以保留树顶，然后开始右遍历<br>

<br>
Java Skill
1.          <br>
2.          <br>



<br>
Last Time completed at :


</div>




</body>
