<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>

遍历的特征，没有返回值， 结果在参数里，从上往下走。

遍历的三部曲：
1. 结束条件
2. 加商业逻辑
3. 往下走

void helper(Node root){
   if ( root == null){
     return;
   }

   dfs(root);
   helper(root.left);
   helper(root.right);
}

customized：
void recursionIncrease(TreeNode root, int count){

    if ( root.left != null &amp;&amp; root.left.val == root.val+1){
        recursionIncrease(root.left, count+1);
    }

    if ( root.right != null &amp;&amp; root.right.val == root.val+1){
        recursionIncrease(root.right, count+1);
    }

    ret =Math.max(ret, count);
}









public class Solution {
    public List&lt;List&lt;Integer>> binaryTreePathSum(TreeNode root, int target) {
        // Write your code here

        ArrayList&lt;List&lt;Integer>> ret = new ArrayList&lt;>();
        ArrayList&lt;Integer> result = new ArrayList&lt;>();
        if ( root == null) return ret;


        result.add(root.val);
        dfs( ret, result, root, target );

        return ret;

    }


    private void dfs( List&lt;List&lt;Integer>> results, List&lt;Integer> result, TreeNode root, int target){

        int sum = 0;
        for( int n : result){
            sum = sum + n;
        }


        // From root node to leaf node means from top to bottom
        if ( sum == target &amp;&amp; root.left == null &amp;&amp; root.right == null){
            results.add( new ArrayList&lt;Integer>(result) );
            return;
        }


        if ( root.left != null){
            result.add(root.left.val);
            dfs(results,result, root.left, target);
            result.remove(result.size()-1);
        }

        if ( root.right != null){
            result.add(root.right.val);
            dfs(results, result, root.right, target);
            result.remove(result.size()-1);
        }
    }
}





</code></pre>






<div class="comment">


all possible sulutions -> DFS -> Binary tree Tranversal ->答案在参数中  <br>


此题的技巧，在遍历之前把树顶先加进去，这样左遍历结束的时候可以保留树顶，然后开始右遍历<br>
</div>




</body>
