<html>

<head>
   <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>


<body>




<pre><code>
class Solution {
    
    int d;
    int f;
    int target;
    
    
    public int numRollsToTarget(int d, int f, int target) {
        this.d = d;
        this.f = f;
        this.target = target;
        
        return dfs(0, 0);
    }
    
    
    int dfs(int curStep, int curSum){
        
        if ( curStep == d){
            if ( curSum == target ){
                return 1;
            }else{
                return 0;
            }
        }

        if ( curSum > target) return 0;   // 减枝


        int total = 0;
        for(int i=1; i&lt;=f; i++){
            total = total + dfs(curStep+1, curSum + i);
        }
        
        return total;
    }
}


Solution II optimization: DFS + Memorization:

1.注意此时的记忆矩阵是 int[][] mem = new int[Step][target] 

2. 记忆矩阵的大小主要是保证不过界，好写理解，没有具体的限制。


class Solution {
    
    int d;
    int f;
    int target;
    Integer[][] dp;
    
    public int numRollsToTarget(int d, int f, int target) {
        this.d = d;
        this.f = f;
        this.target = target;
        dp = new Integer[d][target+1];    
        return dfs(0, 0);
    }
    
    
    int dfs(int curStep, int curSum){
        
        if ( curStep == d){
            if ( curSum == target ){
                return 1;
            }else{
                return 0;
            }
        }
        
        if ( curSum > target) return 0;

        if ( dp[curStep][curSum] != null) return dp[curStep][curSum];

        int total = 0;
        for(int i=1; i&lt;=f; i++){
            total = total + dfs(curStep+1, curSum + i);
        }
        
        dp[curStep][curSum] = total;

        return total;
    }
}

</code></pre>

</div>




</body>
