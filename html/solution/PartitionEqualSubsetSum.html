<html>

<head>
  <link rel="stylesheet" type="text/css" href="../../css/utility.css">     <!-- external css file -->
</head>

<body>
<pre><code>


思维方式:  DFS暴力 => DFS + Mem => DP(不一定能写出来)

Solution 0: DFS not return value( cannot be used for DFS + memo)

class Solution {
    boolean ret = false;
    public boolean canPartition(int[] nums) {
        
        int sum = 0;
        for( int i : nums){
            sum = sum + i;
        }
        
        if ( sum%2 == 1) return false;
        
        dfs(0, sum/2, nums, 0);
        return ret;
    }
    
    
    void dfs(int sum, int target, int[] nums, int pos){

        if ( sum > target) return;

        if ( sum == target){
            ret = true;
            return;
        }

        if ( pos == nums.length()) return;

        
        for( int i=pos; i&lt;nums.length; i++){
            sum = sum + nums[i];
            dfs(sum, target, nums, i+1);
            sum = sum - nums[i];
        }
    }
}

Solution I:  DFS(return value)

   class Solution {

      public boolean canPartition(int[] nums) {
          
          int sum = 0;
          for( int i : nums){
              sum = sum + i;
          }
          
          if ( sum%2 == 1) return false;
          
          return dfs(0, sum/2, nums, 0);
      }
      
      
      boolean dfs(int sum, int target, int[] nums, int pos){
          
          if ( sum > target) return false;
          
          if ( sum == target){
            return true;
          }
          
          if ( pos == nums.length) return false;  
         
          return dfs(sum + nums[pos], target, nums, pos + 1) ||
                 dfs(sum,             target, nums, pos + 1);
      }
  }


Solution II: DFS ( return value) + Mem

class Solution {
    
    Boolean[][] dp;

    public boolean canPartition(int[] nums) {
        
        int sum = 0;
        for( int i : nums){
            sum = sum + i;
        }
        
        if ( sum%2 == 1) return false;
        
        dp = new Boolean[nums.length][sum/2 + 1];
        
        
        return dfs(0, sum/2, nums, 0);
    }
    
    
    boolean dfs(int sum, int target, int[] nums, int pos){

        if ( sum > target) return false;
            
        if ( sum == target){
            return true;
        }        
        if ( pos == nums.length) return false;
        

        if ( dp[pos][sum] != null ) return dp[pos][sum]; 

       
        dp[pos][sum] = dfs(sum + nums[pos], target, nums, pos + 1) ||
               dfs(sum, target, nums, pos + 1);
        
         
        
        return dp[pos][sum];
    }
}
</code></pre>
</body>
